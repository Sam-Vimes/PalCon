@{
    ViewBag.Title = "Home Page";
    Layout = null;
}

<html>
<head>
    <style>
        input {
            border-radius: 5px;
            width: 40px;
            padding: 2px 7px;
        }

        label {
            width: 150px;
            display: inline-block;
            text-align: right;
        }

        button {
            border-radius: 5px;
            padding: 5px;
            font-weight: bold;
        }

            button:hover {
                cursor: pointer;
            }

#instructions {
    padding:5px;
    margin:5px;
    border-radius:5px;
    color:#bbb;
    background-color:black;
}
        #instructions span {
            margin-left: 12px;
        }

        .rows > div {
            margin-bottom: 5px;
        }

        body {
            overflow: hidden;
        }
    </style>
    <script src="/Scripts/jquery-1.10.2.min.js"></script>
    <script src="/Scripts/jquery.signalR-2.1.2.min.js"></script>
    <script src="/signalr/hubs"></script>
    <script src="~/Scripts/howler.js"></script>

    <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>




    <script>

        // SIGNALR
        var myHub;
        var test;
        var keys = [];
        var keyconst = {};
        keyconst.ctrl = 17;
        keyconst.z = 90;
        keyconst.x = 88;
        $(function () {
            myHub = $.connection.palconHub;

            myHub.client.playerJoined = function (newNumPlayers) {
                numPlayers = newNumPlayers;
                $("#playersLabel").html(numPlayers);
            }

            myHub.client.joinSuccess = function (aGameId) {
                gameId = aGameId;
                $("button").css('visibility', 'visible');
                showSettings();
            }

            myHub.client.checkReadyToStart = function () {
                console.log('server asking ready to start');
                myHub.server.clientReadyToStart(gameId).done(function () {
                    console.log('told server ready to start');
                });
                init();
            }

            myHub.client.receiveMap = function (myPlayerId, json) {
                ownerIndex = myPlayerId;
                $("body").css("background-color", ownercolours[ownerIndex]);

                //console.log(json);

                var map = JSON.parse(json);

                // INIT GAME

                processGameBoard(map);
                setTimeout(startTicker, 500);
            }

            myHub.client.receiveCommands = function (json) {
                //console.log('got commands on tick ' + tickInTurn);
                //console.log(json);
                var obj = JSON.parse(json);
                incomingCommands = obj.commands;
                //console.log(incomingCommands);
                if (obj.turnId != turnId + 1) {
                    //alert('You seem to be out of sync with the rest of the players.  You can continue playing, but unexpected results might occur');
                    console.log('missed turn? ' + obj.turnId + ' ' + turnId);
                }
                turnId = obj.turnId;
                doTick(); // if in background, ensure commands get processed soonish?
                //handleIncoming(incomingCommands);
            }

            myHub.client.receiveSettings = function (jsonstr) {
                console.log('received settings');
                var settings = JSON.parse(jsonstr);
                fleetspeed = settings.speed;
                growthrate = settings.growth;
                planetsPerPlayer = settings.ppp;
                neutralPlanetCost = settings.costs;
                attackRatio = settings.attack;
                showSettings();
                test = settings;
            }

            $.connection.hub.start().done(function () {
                myHub.server.joinGame();
            });



            $(window).keydown(
                function (e) {
                    keys[e.which] = true;

                    if (e.which == keyconst.x) {
                        cancelRecurringOrders();
                    }
                    if (e.which == keyconst.z) {
                        e.preventDefault();
                    }
                }
            );
            $(window).keyup(
                function (e) {
                    keys[e.which] = false;
                    if (e.which == keyconst.z) {
                        e.preventDefault();
                    }
                }
            );

            var context;
            try {
                // Fix up for prefixing
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                context = new AudioContext();
            }
            catch (e) {
                alert('Web Audio API is not supported in this browser');
            }
            sound_conquer = new Howl({
                src: ['/content/nff-timpani-low.wav']
            });
            sound_warning = new Howl({
                src: ['/content/nff-pick.wav'],
                volume:.2
            });
            sound_attack = new Howl({
                src: ['/content/blop.mp3']
            });
            

            //var sound_conquer = new Howl({
            //    src: ['/content/nff-timpani-low.wav'],
            //    volume: 0.5
            //});
            //sound_conquer.play();
            //sound_conquer.stereo(0);

        });


        function isPressed(which) {
            return keys[which];
        }

        function sendSettings() {
            var settings = {};
            settings.speed = $("#fleetspeed").val();
            settings.growth = $("#growthrate").val();
            settings.ppp = $("#ppp").val();
            settings.costs = $("#costs").val();
            settings.attack = $("#attack").val();
            myHub.server.sendSettings(gameId, JSON.stringify(settings));

        }

        function showSettings() {
            $("#fleetspeed").val(fleetspeed);
            $("#growthrate").val(growthrate);
            $("#ppp").val(planetsPerPlayer);
            $("#costs").val(neutralPlanetCost);
            $("#attack").val(attackRatio);
        }

        function sendQueue(json) {
            myHub.server.sendCommands(gameId, JSON.stringify(json));
        }

        function startGame() {
            sendSettings(); // somebody could have joined since last settings change.
            myHub.server.tryStartGame(gameId)
            .done(function (result) {
                numPlayers = result;
                if (numPlayers > 0) {
                    console.log('server says numplayers: ' + numPlayers);
                    var json = JSON.stringify(generateGameBoard());
                    myHub.server.sendMap(gameId, json);

                }
            });

        }

        // CONFIGURABLE SETTINGS

        var ticksPerTurn = 10;
        var msPerTurn = 500;
        var growthrate = 100;
        var fleetspeed = 100;
        var neutralPlanetCost = 50;
        var attackRatio = .8;

        var planetradiuspercent = 1.9;
        var planetRadiusPixels = 0;

        var planetsPerPlayer = 7;
        var numPlayers = 0;
        var gameId;

        // UI
        var highlights = [];

        var highlightedPlanets = [];



        var sendPercentBars = [];
        var sendDestPlanet;
        var sendPercent;
        var sendPercentDelta;
        var sendInProgress;

        var layers = {};


        var sound_conquer;
        var sound_attack;
        var sound_warning;

        function startSendPercentBar(destPlanet) {
            if (!highlightedPlanets.length)
                return;
            sendDestPlanet = destPlanet;
            sendPercentDelta = 4;
            sendPercent = 0;
            var highlightedPlanet;
            for (var idx in highlightedPlanets) {
                var sendPercentBar = new createjs.Shape();
                layers.planets.addChild(sendPercentBar);

                highlightedPlanet = highlightedPlanets[idx];
                sendPercentBar.graphics.setStrokeStyle(7 * globalscale, 'square', 'miter', 0, true);
                //sendPercentBar.graphics.setStrokeDash([1, 10*globalscale], 0);
                sendPercentBar.alpha = .6;
                var col = ownercolours[ownerIndex];
                if (isPressed(keyconst.z)) {
                    col = "#fff";
                }
                sendPercentBar.graphics.beginStroke(col);

                drawSurfacePath(highlightedPlanet, destPlanet, sendPercentBar);

                sendPercentBar.scaleX = sendPercentBar.scaleY = 0;

                layers.planets.addChild(sendPercentBar);
                sendPercentBars.push(sendPercentBar);
            }
            sendInProgress = true;
            //console.log('created bar');
            //return sendpercentBar;
        }

        function cancelSend() {
            for (var idx in sendPercentBars) {
                layers.planets.removeChild(sendPercentBars[idx]);
            }
            sendPercentBars = [];
            sendInProgress = false;

        }

        function tryCreateCommand(fromPlanet, toPlanet, sendPercent) {
            if (fromPlanet && fromPlanet.owner == ownerIndex && toPlanet != fromPlanet) {
                var pop = Math.round(fromPlanet.pop / 100 * sendPercent);

                if (pop >= 1) {
                    //console.log('sending ' + pop + ' remaning: ' + fromPlanet.pop - pop);
                    queuedCommands.push(
                        {
                            owner: ownerIndex,
                            pop: pop,
                            from: fromPlanet.index,
                            to: toPlanet.index
                        }
                       );
                    showOrderStart(fromPlanet.x, fromPlanet.y, fromPlanet.radius, ownerIndex);
                }
            }
        }

        function doSend() {
            //stage.removeChild(sendPercentBar);
            var planet = sendDestPlanet;
            if (sendPercent > 95)
                sendPercent = 105; // clearly they want to just send everyone
            if (sendPercent < 10)
                sendPercent = 10;
            for (var idx in highlightedPlanets) {
                var highlightedPlanet = highlightedPlanets[idx];
                tryCreateCommand(highlightedPlanet, planet, sendPercent);

                if (isPressed(keyconst.z)) {
                    console.log('creating recurring order');
                    recurringOrders.push(new RecurringOrder(highlightedPlanet, planet, sendPercent));
                }
            }
            cancelSend();
        }

        function updateSendProgress() {
            sendPercent += sendPercentDelta;
            if (sendPercent > 100 || sendPercent < 0) {
                sendPercnet = sendPercent - sendPercentDelta;
                sendPercentDelta = 0 - sendPercentDelta;
            }
            var sendPercentBar;
            for (var idx in sendPercentBars) {
                sendPercentBar = sendPercentBars[idx];
                sendPercentBar.scaleX = sendPercentBar.scaleY = sendPercent / 100;
            }
        }

        // ENTITIES

        function RecurringOrder(from, to, percent) {
            this.lastExec = turnId;
            this.intervalTurns = 30;
            this.from = from;
            this.to = to;
            this.percent = percent;
            //this.amount = amount;
            this.shape = recurringPath(this);
            layers.paths.addChild(this.shape);
        }

        function Planet(growth, x, y, pop, owner) {
            this.index = planets.length;
            this.x = x;
            this.y = y;

            this.pop = pop;
            this.owner = owner;
            this.growth = growth;
            this.radius = Math.sqrt(growth) * planetRadiusPixels;   // pixels
            this.shape = planetShape(this.radius, x, y, owner);
            this.label = planetLabel(this);
            this.highlight = null;
            layers.planets.addChild(this.shape);
            layers.planets.addChild(this.label);
            var planet = this;

            var clickable = planetClickableShape(this);
            layers.planets.addChild(clickable);

            clickable.addEventListener("click", function (evt) {

                var isRight = (evt.nativeEvent.button == 2);
                if (isRight) {
                    console.log('mouseup');
                    if (sendInProgress)
                        doSend();
                }
            });

            clickable.addEventListener("mouseout", function (evt) {
                console.log('mouseout');
                if (sendInProgress)
                    cancelSend();
            });


            clickable.addEventListener("mousedown", function (evt) {
                console.log(evt);
                var isRight = (evt.nativeEvent.button == 2);
                if (isRight) {
                    if (sendInProgress) {
                        // something went wrong. prev send failed to cancel on mouseup.
                        cancelSend();
                    }
                    if (highlightedPlanets.length && (highlightedPlanets.length > 1 || planet.highlight == null)) {
                        startSendPercentBar(planet);
                    }
                }
                else {
                    if (planet.owner == ownerIndex) {
                        if (!isPressed(keyconst.ctrl)) {

                            var p;
                            for (var idx in highlightedPlanets) {
                                p = highlightedPlanets[idx];
                                layers.planets.removeChild(p.highlight);
                                p.highlight = null;
                            }
                            highlightedPlanets = [];
                        }
                        if (planet.highlight == null) {
                            planet.highlight = highlightShape(planet);
                            layers.planets.addChild(planet.highlight);

                            highlightedPlanets.push(planet);
                        }
                        else {
                            layers.planets.removeChild(planet.highlight);
                            planet.highlight = null;
                            highlightedPlanets.splice(jQuery.inArray(planet, highlightedPlanets), 1);
                        }
                    }

                }
            });

        }

        function Fleet(pop, startPlanet, destination, owner) {
            this.pop = pop;
            this.owner = owner;
            this.destination = destination;
            var xdist = destination.shape.x - startPlanet.shape.x;
            var ydist = destination.shape.y - startPlanet.shape.y;
            var angle = Math.atan(ydist / xdist);
            if (xdist < 0) {
                angle = angle - Math.PI;
                //this.dx = 0 - this.dx;
                //this.dy = 0 - this.dy;
            }
            this.dx = globalscale * Math.cos(angle) * fleetspeed / 10 / ticksPerTurn;
            this.dy = globalscale * Math.sin(angle) * fleetspeed / 10 / ticksPerTurn;

            this.shape = fleetShape(Math.sqrt(pop), startPlanet.shape.x, startPlanet.shape.y, owner, angle);
            this.path = fleetPath(startPlanet, destination, owner);
            this.size = Math.sqrt(pop);

            layers.ships.addChild(this.shape);
            layers.paths.addChild(this.path);
            //stage.setChildIndex(this.shape, 3);
            //layers.planets.setChildIndex(this.path, 1);
        }


        // COMMS WITH SERVER
        var recurringOrders = [];
        var queuedCommands = [];
        var incomingCommands = [];

        function handleIncoming(commands) {
            var c;
            for (idx in commands) {
                c = commands[idx];
                var fromPlanet = planets[c.from];
                var toPlanet = planets[c.to];
                var pop = c.pop;
                if (pop > fromPlanet.pop)
                    pop = Math.round(fromPlanet.pop - .5);
                if (pop > 0 && fromPlanet.owner == c.owner) {
                    var f = new Fleet(pop, fromPlanet, toPlanet, c.owner);
                    fleets.push(f);
                    fromPlanet.pop -= pop;

                    if (toPlanet.owner == ownerIndex)
                    {
                        var s = sound_warning.play();
                        sound_warning.stereo(fromPlanet.x / xbound * 2 - 1, s);
                        var rate = 1.7 - Math.sqrt(pop) / 10;
                        if (rate < .7)
                            rate = .7;
                        var volume = Math.sqrt(pop+10) / 10 - .3;
                        if (volume > 1)
                            volume = 1;
                        sound_warning.rate(rate, s);
                        sound_warning.volume(volume, s);
                    }

                }
                else {
                    console.log('no pop or planet changed hands');
                }
            }
            incomingCommands = null;
            //console.log('sent queue & handled incoming, tick ' + tickInTurn);
        }

        // GAME TIMING AND MECHANICS


        var tickInTurn = 0;
        var timeStartTurn = 0;
        var turnId = 0;

        var planets = [];
        var fleets = [];

        var stage;
        var globalscale;
        var xbound, ybound;
        var ownercolours = ['#dddddd', '#ffd400', '#ff6688', '#00eeee', '#50f050', '#8899ff', '#ff00ff', '#aacc00', '#ffffff'];

        var ownerIndex = null;

        function newScaledShape() {
            var shape = new createjs.Shape();
            shape.scaleX = globalscale;
            shape.scaleY = globalscale;
            return shape;
        }

        function planetLabel(planet) {
            var txt = new createjs.Text("_", "bold 14px arial", ownercolours[planet.owner]);
            txt.scaleX = globalscale;
            txt.scaleY = globalscale;
            return txt;
        }

        function planetShape(size, x, y, owner) {

            var shape = new createjs.Container();
            var strokeWidth = 2 * globalscale;
            var isize = size - strokeWidth;
            var col = ownercolours[owner];
            var circle = new createjs.Shape();
            shape.addChild(circle);
            circle.graphics.setStrokeStyle(strokeWidth);
            circle.graphics.beginStroke(col);
            circle.graphics.beginRadialGradientFill([ownercolours[owner], "#000"], [0, 1],
            0, 0, isize,
             isize * .3 + globalscale, isize * .3 + globalscale, isize * 1.2).drawCircle(0, 0, isize);
            circle.x = 0;
            circle.y = 0;
            var plain = new createjs.Shape();
            plain.graphics.beginFill(col).drawCircle(0, 0, isize - strokeWidth + .5 * globalscale);
            plain.alpha = .1;
            var circle2 = new createjs.Shape();
            var size2 = isize - strokeWidth + .5 * globalscale;
            circle2.alpha = .3;
            circle2.graphics.beginRadialGradientFill([ownercolours[owner], "#000"], [0, 1],
            0, 0, size2,
             size2 * .4 + globalscale, size2 * .4 + globalscale, size2 * 1.1).drawCircle(0, 0, size2);
            //circle2.graphics.beginFill(col).drawCircle(0, 0, isize - strokeWidth+.5*globalscale);

            shape.addChild(circle2);
            shape.addChild(plain);
            shape.x = x;
            shape.y = y;

            //circle.graphics.beginRadialGradientFill(["#000", ownercolours[owner], "#fff"], [0, 1,2], size/2, size/2, 0, size, size, size).drawCircle(size/2,size/2,size*.7);
            //circle.graphics.beginRadialGradientFill(["#000", ownercolours[owner]], [0, 1], size *.3, size *.3, size*.7, size/2, size/2, size*.8).drawCircle(size *.4, size *.4, size * .6);
            //            circle.graphics.beginRadialGradientFill(["#0f0", "#000"], [0, 1], 0-isize*.4, 0-isize*.4, isize, isize*.4, isize*.4,isize*1.4).drawCircle(0,0,size);


            return shape;
        }

        function planetClickableShape(planet) {
            var circle = new createjs.Shape();
            //circle.graphics.setStrokeStyle(3 * globalscale);
            circle.graphics.beginFill(ownercolours[planet.owner])
            .drawCircle(0, 0, planet.radius + 5);
            circle.alpha = .01;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function highlightShape(planet) {
            var circle = new createjs.Shape();
            var width = 8 * globalscale;
            circle.graphics.setStrokeStyle(width);
            circle.graphics.beginStroke(ownercolours[planet.owner]).drawCircle(0, 0, planet.radius);
            //circle.graphics.setStrokeStyle(1.5 * globalscale);
            //circle.graphics.beginStroke("#fff").drawCircle(0, 0, planet.radius + width/2);
            circle.alpha = .8;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function fleetShape(size, x, y, owner, angle) {
            var col = ownercolours[owner];
            var container = new createjs.Container();
            var shape = new createjs.Shape();
            var shapeNoShadow = new createjs.Shape();
            container.addChild(shape);
            container.addChild(shapeNoShadow);

            container.scaleX = container.scaleY = globalscale * size * .7 + 1.5;


            //shape.graphics.setStrokeStyle(1 + .1 * scale * globalscale, 'butt', 'round', 0, true);
            //shape.graphics.beginStroke(col);
            shape.graphics.beginFill(col);

            shape.graphics.moveTo(1, 2);
            shape.graphics.lineTo(-.7, .3);
            shape.graphics.lineTo(-.5, 0);

            shape.graphics.lineTo(1, .5);
            shape.graphics.lineTo(2.5, 0);
            shape.graphics.lineTo(2.7, .3);
            shape.graphics.lineTo(1, 2);

            shape.graphics.endStroke();
            shape.graphics.endFill();
            shape.graphics.beginRadialGradientFill([col, "#000"], [0, 1],
            -5, 0, 7, -5.5, 0, 4).drawEllipse(0, 0, 2, 3);

            shape.shadow = new createjs.Shadow("#000000", 3 + size * globalscale / 10, 3 + size * globalscale / 10, globalscale * (10 + size));

            shapeNoShadow.graphics.beginLinearGradientFill([col, "#fff"], [1, 0], -1, 2.5, 1.5, 2.5)
            //shape.graphics.beginRadialGradientFill(["#000","#000", col,"#fff"], [0,.4,.8, 1],
            //1, 2.2, 2,
            // 1.3, 2.5, .02).drawEllipse(.4, 1.5, 1.2, 1.7);
            .drawEllipse(.4, 1.2, 1.2, 1.2);
            //.drawEllipse(-10, -10, 20, 40);




            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff",col, "#000000"], [0,.3,.3,.45, 1], 4, -1, -2, 3);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff", col, "#000000"], [0, 0,0, .35, 1], 2.5, .5, -3, 2);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff", col, "#000000"], [0, .1,.1, .25, 1], 3, 0, -2, 0);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(2, 0);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.endFill();
            //shape.graphics.setStrokeStyle(1 + .01 * scale, 'butt', 'round', 0, true);
            //shape.graphics.beginStroke(col);
            //shape.graphics.moveTo(2, 0);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(2, 0).lineTo(0, 3);


            container.regX = 1;
            container.regY = 1.5;
            container.x = x;
            container.y = y;
            container.rotation = angle * 180 / Math.PI - 90;
            if (container.rotation < 0)
                container.rotation += 360;
            //shape.rotation += 0 - 90 - angle * 180/ Math.PI;
            return container;
        }

        function drawSurfacePath(planet1, planet2, shape) {
            console.log(planet2);
            console.log(planet2);
            var x = planet1.x;
            var y = planet1.y;
            var xd = (planet2.x - x);
            var yd = (planet2.y - y);
            var dist = Math.sqrt(xd * xd + yd * yd);
            var startRadProportion = planet1.radius / dist;
            var startCuttoffX = xd * startRadProportion;
            var startCuttoffY = yd * startRadProportion;
            x = x + startCuttoffX;
            y = y + startCuttoffY;
            var endRadProportion = planet2.radius / dist;
            xd = xd - xd * endRadProportion - startCuttoffX;
            yd = yd - yd * endRadProportion - startCuttoffY;
            shape.graphics.moveTo(0, 0);
            shape.graphics.lineTo(xd, yd);
            shape.x = x;
            shape.y = y;
            console.log('drawing ' + x + ',' + y + ' to ' + xd);
        }

        function recurringPath(recurring) {
            var shape = new createjs.Shape();
            shape.alpha = .4;
            width = (2 + recurring.percent * .04) * globalscale;
            shape.graphics.setStrokeStyle(width, 0, 0, 0, true);
            //shape.graphics.setStrokeDash([2 * globalscale, 2 * globalscale], 0);
            shape.graphics.beginStroke("#ffffff");

            drawSurfacePath(recurring.from, recurring.to, shape);
            return shape;

        }

        function fleetPath(p1, p2, owner, width) {
            if (!width)
                width = 3 * globalscale;
            var shape = new createjs.Shape();
            shape.graphics.setStrokeStyle(width, 0, 0, 0, true);
            shape.graphics.setStrokeDash([2 * globalscale, 2 * globalscale], 0);
            shape.graphics.beginStroke(ownercolours[owner]);
            drawSurfacePath(p1, p2, shape);
            //shape.graphics.moveTo(0, 0);
            //shape.graphics.lineTo(x2 - x1, y2 - y1);
            shape.alpha = .3;
            //shape.x = x1;
            //shape.y = y1;
            return shape;
        }

        function bg() {
            var bg = new createjs.Shape();
            bg.scaleX = 1;
            bg.scaleY = 1;
            bg.graphics.beginFill("#000000").drawRect(0, 0, xbound, ybound);
            bg.x = 0;
            bg.y = 0;
            return bg;
        }

        function processGameBoard(planetArray) {
            for (idx in planetArray) {
                var j = planetArray[idx];
                var p = new Planet(j.growth, j.x * globalscale * 10, j.y * globalscale * 10, j.pop, j.owner);
                planets.push(p);
            }
        }

        function generateGameBoard() {
            function overlap(obj) {
                var gap = 1.5;
                for (idx in planetArray) {
                    var p = planetArray[idx];
                    if (p.x - p.radius - gap < obj.x + obj.radius && p.x + p.radius + gap > obj.x - obj.radius) {
                        if (p.y - p.radius - gap < obj.y + obj.radius && p.y + p.radius + gap > obj.y - obj.radius) {
                            return true;
                        }
                    }
                }
                return false;
            }

            planetArray = [];
            var newPlanet;
            for (i = 1; i <= numPlayers; i++) {
                var growth = 4;
                var canadd = false;
                var tries = 0;
                while (!canadd) {
                    var radius = Math.sqrt(growth) * planetradiuspercent;
                    newPlanet =
                    {
                        owner: i,
                        x: Math.random() * (100 - radius * 2) + radius,
                        y: Math.random() * (50 - radius * 2) + radius,
                        pop: 100,
                        growth: growth,
                        radius: radius
                    };
                    canadd = !overlap(newPlanet);
                    if (!canadd) {
                        //console.log(newPlanet);
                    }
                    tries++;
                    if (tries > 100) {
                        alert('can\'t find a place to add new planet.  too many planets');
                        return;
                    }
                }
                planetArray.push(newPlanet);
            }
            var growth = 4;
            var extraCost = 50;
            var numNeutrals = numPlayers * (planetsPerPlayer - 1) + 1;
            if (numNeutrals > 100)
                numNeutrals = 100;
            //console.log(numNeutrals);
            for (i = 0; i < numNeutrals; i++) {
                if (i == 1) {
                    growth = 1;
                    extraCost = 0;
                }
                if (i * 2 >= numNeutrals)
                    growth = 2;
                var canadd = false;
                var tries = 0;
                while (!canadd) {
                    var radius = Math.sqrt(growth) * planetradiuspercent;
                    newPlanet =
                    {
                        owner: 0,
                        x: Math.random() * (100 - radius * 2) + radius,
                        y: Math.random() * (50 - radius * 2) + radius,
                        pop: growth * neutralPlanetCost / 5 + Math.random() * growth * neutralPlanetCost / 5 + extraCost,
                        growth: growth,
                        radius: radius
                    };
                    canadd = !overlap(newPlanet);
                    if (!canadd) {
                        //console.log(newPlanet);
                    }
                    tries++;
                    if (tries > 100) {
                        //alert('can\'t find a place to add new planet.  too many planets');
                        return planetArray;
                    }
                }
                planetArray.push(newPlanet);
            }
            //console.log(planetArray);
            return planetArray;

        }

        function init() {
            $("#pregame").hide();

            document.getElementById("PalCanvas").addEventListener('contextmenu', function (e) {
                if (e.button === 2) {
                    e.preventDefault();
                    return false;
                }
            }, false);
            document.getElementById("PalCanvas").setAttribute('width', window.innerWidth);
            document.getElementById("PalCanvas").setAttribute('height', window.innerWidth / 2);
            xbound = document.getElementById("PalCanvas").width;
            ybound = document.getElementById("PalCanvas").height;
            globalscale = xbound / 1000;
            planetRadiusPixels = planetradiuspercent * globalscale * 10;



            //var planetsData = generateGameBoard();




            // code here.
            stage = new createjs.Stage("PalCanvas");
            stage.enableMouseOver(10);
            stage.update();
            stage.addChild(bg());
            layers.planets = new createjs.Container();
            layers.paths = new createjs.Container();
            stage.addChild(layers.paths);
            stage.addChild(layers.planets);
            layers.ships = new createjs.Container();
            stage.addChild(layers.ships);


            // must be after setting globalscale and initing stage:
            //processGameBoard(planetsData);

            //var p = new Planet(1, 50, 50, 101.3, 0);
            //planets.push(p);
            //p = new Planet(2, 600, 140, 5, 1);
            //planets.push(p);
            //p = new Planet(4, 510, 210, 50, 0);
            //planets.push(p);

            //var f = new Fleet(15, planets[2], planets[1], 0);
            //fleets.push(f);

            //f = new Fleet(3, planets[1], planets[0], 1);
            //fleets.push(f);
            //f = new Fleet(80, planets[1], planets[2], 1);
            //fleets.push(f);
        }

        function startTicker() {

            createjs.Ticker.setFPS(ticksPerTurn / msPerTurn * 1000);
            createjs.Ticker.addEventListener("tick", handleTick);
            timeStartTurn = new Date().getTime();
        }

        function updatePlanet(p) {

            if (p.owner > 0) {
                if (p.pop < p.growth * 100) {
                    p.pop += p.growth * growthrate / ticksPerTurn / 500;
                }

            }
            var isOverpopulated = p.pop > p.growth * 100 - 1; // 1 wiggle room for rounding because using test to check
            var newText = Math.round(p.pop);

            if (newText != p.label.text) {
                if (isOverpopulated)
                    p.label.color = "#bbbbbb"
                else
                    p.label.color = ownercolours[p.owner];
                p.label.text = newText;
                p.label.x = p.x - globalscale * p.label.getBounds().width / 2;
                p.label.y = p.y - globalscale * p.label.getMeasuredHeight() / 2;
            }


        }

        function moveFleet(f, idx) {
            if (f != null) {
                var distToGo = Math.sqrt(Math.pow((f.shape.x - f.destination.shape.x), 2) + Math.pow((f.shape.y - f.destination.shape.y), 2));

                if (distToGo < f.destination.radius) {
                    //console.log(distToGo);
                    land(f);
                    fleets[idx] = null;
                    layers.paths.removeChild(f.path);

                }
                else {
                    f.shape.x += f.dx;
                    f.shape.y += f.dy;
                    //createjs.Tween.get(f.shape)
                    //.to({ x: f.shape.x + f.dx, y: f.shape.y + f.dy }, msPerTurn / ticksPerTurn);
                }
            }
        }

        function showOrderStart(x, y, radius, owner) {
            var circle = new createjs.Shape();
            circle.graphics.setStrokeStyle(8 * globalscale);
            circle.graphics.beginStroke(ownercolours[owner]).drawCircle(0, 0, radius - 3);
            circle.x = x;
            circle.y = y;
            circle.scaleX = 1;
            circle.scaleY = 1;
            circle.alpha = .7;
            layers.planets.addChild(circle);
            createjs.Tween.get(circle)
                    .to({ scaleX: 0, scaleY: 0 }, msPerTurn * 2);
            //                    .to({ scaleX: 1, scaleY: 1, alpha: 0 }, msPerTurn * 2, createjs.Ease.quintOut);

        }

        function showExplosion(x, y, size, owner, timeScale, noBrightPatch) {
            if (!timeScale)
                timeScale = 1;
            var circle = new createjs.Shape();
            circle.graphics.setStrokeStyle(10 * globalscale);
            circle.graphics.beginFill(ownercolours[owner]).drawCircle(0, 0, 5 + size * 2);
            circle.x = x;
            circle.y = y;
            circle.scaleX = .1;
            circle.scaleY = .1;
            circle.alpha = 1;
            layers.ships.addChild(circle);

            var tween = createjs.Tween.get(circle);
            if (!noBrightPatch) {
                tween.to({ scaleX: .3, scaleY: .3 }, msPerTurn * .15 * timeScale);
            }
            tween.to({ scaleX: 1, scaleY: 1, alpha: 0 }, msPerTurn * 2 * timeScale, createjs.Ease.quintOut);
        }

        function land(f) {


            var p = f.destination;
            var pop = f.pop;
            if (f.owner != f.destination.owner) {
                
                showExplosion(f.shape.x, f.shape.y, f.shape.scaleX, f.owner);
                layers.ships.removeChild(f.shape);
                var damage = f.pop * attackRatio;
                if (f.destination.pop >= damage) {
                    f.destination.pop -= damage;

                    var s = sound_attack.play();
                    sound_attack.stereo(p.x / xbound * 2 - 1, s);
                    var rate = 2 - Math.sqrt(pop) * .15;
                    if (rate < .5)
                        rate = .5;
                    var volume = Math.sqrt(pop+10) / 10 - .3;
                    if (volume > 1)
                        volume = 1;
                    sound_attack.rate(rate, s);
                    sound_attack.volume(volume, s);

                }
                else {
                    fleetLoss = f.destination.pop / attackRatio;
                    f.destination.pop = f.pop - fleetLoss;

                    showExplosion(p.x, p.y, p.radius * 3, p.owner, 2, true);
                    var ex = p.x;
                    var ey = p.y;
                    var er = p.radius * 3;
                    var fowner = f.owner;
                    setTimeout(function () {
                        showExplosion(ex, ey, er, fowner, 2, true);
                    }, 200);
                    for (var idx in highlightedPlanets) {
                        if (highlightedPlanets[idx] == p) {
                            highlightedPlanets.splice(idx, 1);
                            //highlightedPlanet = null;
                            layers.planets.removeChild(p.highlight);
                            p.highlight = null;
                        }
                    }
                    p.owner = f.owner;
                    layers.planets.removeChild(p.shape);
                    layers.planets.removeChild(p.label);
                    p.shape = planetShape(p.radius, p.x, p.y, p.owner);
                    p.label = planetLabel(p);
                    layers.planets.addChild(p.shape);
                    layers.planets.addChild(p.label);

                    //sound_conquer.stereo(1);
                    var s = sound_conquer.play();
                    sound_conquer.stereo(p.x / xbound * 2 - 1, s);
                    sound_conquer.rate(1.7 - p.growth*.25, s);

                }
            }
            else {

                var tween = createjs.Tween.get(f.shape);
                targetx = (f.shape.x * 2 + f.destination.x) / 3;
                targety = (f.shape.y * 2 + f.destination.y) / 3;

                showExplosion(targetx, targety, f.shape.scaleX, f.owner);
                if (f.shape.rotation + Math.random() * 100 - 50 < 180)
                    rotate = 270 + Math.random() * 50 - 25;
                else
                    rotate = 90 + Math.random() * 50 - 25;
                if (rotate - f.shape.rotation > 360)
                    rotate -= 360;
                if (rotate - f.shape.rotation < -360)
                    rotate += 360;
                var moreRotate = rotate + (rotate - f.shape.rotation) / 2;
                tween.to({ rotation: rotate }, msPerTurn * 2, createjs.Ease.cubicInOut)
                .to({ rotation: moreRotate, scaleX: f.shape.scaleX / 5.5, scaleY: f.shape.scaleY / 4, x: targetx, y: targety + f.size / 3 + 2 }, msPerTurn * 2, createjs.Ease.cubicInOut);

                f.destination.pop += f.pop;

                setTimeout(function () {
                    layers.ships.removeChild(f.shape);
                }, msPerTurn * 4)

                setTimeout(function () {

                }, msPerTurn)


            }

        }

        function processRecurringOrders() {
            for (var idx in recurringOrders) {
                // not perfect, but good enough:
                var o = recurringOrders[idx];
                if (o.from.owner != ownerIndex)
                    cancelRecurringOrder(o);
            }
            for (var idx in recurringOrders) {
                var o = recurringOrders[idx];

                if (o.lastExec + o.intervalTurns <= turnId) {
                    tryCreateCommand(o.from, o.to, o.percent);
                    o.lastExec = turnId;

                }
            }
        }

        function cancelRecurringOrder(o) {
            layers.paths.removeChild(o.shape);
            recurringOrders.splice(jQuery.inArray(o, recurringOrders), 1);
        }

        function cancelRecurringOrders() {


            for (var pi in highlightedPlanets) {

                var p = highlightedPlanets[pi];
                console.log('-----------------');
                console.log(p);
                for (var idx = 0; idx < recurringOrders.length; idx++) {
                    var o = recurringOrders[idx];
                    console.log(o.from);
                    if (o.from == p) {
                        cancelRecurringOrder(o);
                        idx--;
                    }
                }
            }

            //recurringOrders = [];
        }

        function doTick() {
            tickInTurn++;
            if (tickInTurn >= ticksPerTurn) {
                // todo
                if (incomingCommands != null) {
                    // sneak in recurring orders just before sending:
                    processRecurringOrders();


                    //console.log('ending on tick ' + tickInTurn);
                    tickInTurn = 0;
                    timeStartTurn = new Date().getTime();

                    sendQueue(queuedCommands);
                    queuedCommands = [];
                    handleIncoming(incomingCommands);

                }
                else if (tickInTurn == ticksPerTurn + 10) {
                    // still waiting. pause.
                    console.log('pausing....');
                }


            }
            else {
                for (f in fleets) {
                    moveFleet(fleets[f], f);
                }
                for (p in planets) {
                    updatePlanet(planets[p]);
                }

                var expectedTime = timeStartTurn + tickInTurn * msPerTurn / ticksPerTurn;
                var actualTime = new Date().getTime();
                var lag = actualTime - expectedTime;
                if (lag > 50) {
                    console.log('lagging by ' + lag + ' ms - catch up');
                    doTick();
                }

            }

        }

        function handleTick(event) {
            // Actions carried out each tick (aka frame)
            if (!event.paused) {
                // Actions carried out when the Ticker is not paused.

                doTick();
                if (sendInProgress)
                    updateSendProgress(); // do this regardless of game lag
                stage.update();
            }
        }
    </script>

</head>
<body onload="" style="margin:0; background-color:#332244">
    <canvas id="PalCanvas" width="1" height="1"></canvas>
    <div id="pregame" style="color:white; padding:10px">
        <h3>PalCon</h3>
        Waiting for players. Joined: <span id="playersLabel"></span>
        <br /><br />
        Suggestion: Before starting, hit <b>F11</b> to go fullscreen</span>
        <br /><br/>
        <button id="btnStart" style="visibility:hidden" onclick="startGame();">START GAME</button>
        <hr />
        <div class="rows">
            <div>
                <label>Fleet Speed: </label>
                <input id="fleetspeed" />
            </div>
            <div>
                <label>Growth Rate:</label>
                <input id="growthrate" />
            </div>
            <div>
                <label>Planets per player:</label>
                <input id="ppp" />
            </div>
            <div>
                <label>Neutral Planet Cost:</label>
                <input id="costs" />
            </div>
            <div>
                <label>Attack ratio:</label>
                <input id="attack" />
            </div>
            <label></label>
            <button style="visibility:hidden" id="btnSettings" onclick="sendSettings();">UPDATE SETTINGS</button>
        </div>
        <hr />

    </div>
    <div id="instructions" style="">

        <div style="float:left">
            <label>Select planets:</label><span>click / ctrl-click</span>
            <br />
            <label>Send fleet:</label><span>hold right-click</span>
        </div>
        <div style="float:left;margin-left:50px">
            <label>Send repeat-order:</label><span>hold <b>Z</b> + right-click</span>
            <br />
            <label>Cancel repeat-orders:</label><span>select planet(s), then <b>X</b></span>

        </div>
        <div style="clear:both"></div>
    </div>
</body>
</html>



<!--function init() {
  var stage = new createjs.Stage("demoCanvas");
  var circle = new createjs.Shape();
  circle.graphics.beginFill("Crimson").drawCircle(0, 0, 50);
  circle.x = 100;
  circle.y = 100;
  stage.addChild(circle);
  createjs.Tween.get(circle, {loop: true})
    .to({x: 400}, 1000, createjs.Ease.getPowInOut(4))
    .to({alpha: 0, y: 75}, 500, createjs.Ease.getPowInOut(2))
    .to({alpha: 0, y: 125}, 100)
    .to({alpha: 1, y: 100}, 500, createjs.Ease.getPowInOut(2))
    .to({x: 100}, 800, createjs.Ease.getPowInOut(2));
  createjs.Ticker.setFPS(60);
  createjs.Ticker.addEventListener("tick", stage);
}-->
