@{
    @model string[]
    ViewBag.Title = "Home Page";
    Layout = null;
}

@*
    TODO
        save settings (but whose take priority?)
        detect disconnect
        shields
        prevent double-click fleet sends
        check colours valid
        break dep. between easeljs ship scale and collission detection
    WARNINGS
        tween using ticks, just in case easeljs being used for gameplay (e.g. ship scale)
*@

<html>
<head>
    <style>
        @@font-face {
            font-family: space;
            src: url("content/space_age.ttf") format("truetype");
        }

        h2 {
            margin-top: 0;
            font-family: space;
        }

        h3 {
            color: white;
            margin-top: 10px;
        }

        * {
            outline-style: none;
        }

        a {
            color: #aec;
        }

        #fullscreen_msg {
            color: white;
            font-weight:bold;
        }
        
         .chrome_warning {
            display: none;
            font-size: 1.5em;
            margin-bottom: 20px;
            padding: 20px;
            background-color: #aa0000;
            color: white;
            text-align: center;
            border-radius: 10px;
        }

        .waitforsignalr {
            font-size: 2em;
            width: 100vw;
            height: 100vh;
            position: fixed;
            background-color: black;
            color: white;
            text-align: center;
        }

            .waitforsignalr > div {
                width: auto;
                margin: auto;
                margin-top: 40vh;
                display: inline-block;
                position: relative;
            }


        .more {
            display: none;
        }

        .more_button {
            display: inline-block;
            font-size: .7em;
            margin-bottom: 10px;
        }

        .top0 {
            margin-top: 5px;
            margin-bottom: 0px;
        }

        input, select {
            border-radius: 5px;
            width: 40px;
            padding: 2px 7px;
        }

        select {
            padding: 2px 2px;
        }

        #pregame {
            width: 60vw;
            float: left;
        }

        .clearfix:after {
            visibility: hidden;
            display: block;
            font-size: 0;
            content: " ";
            clear: both;
            height: 0;
        }

        #pregame label {
            /*width: 150px;*/
            /*display: inline-block;*/
            text-align: right;
        }

        button {
            border-radius: 5px;
            padding: 5px;
            font-weight: bold;
        }

            button:hover {
                cursor: pointer;
            }

        #instructions {
            border-radius: 5px;
            color: #bbb;
            background-color: black;
            font-size: .8em;
            padding: 5px;
            /*margin-right:-99%;
            width:100%;
            float:left;*/
        }

            #instructions label {
                display: block;
                margin-left: 0;
                text-align: left;
            }

            #instructions span {
                display: inline-block;
                margin-left: 12px;
            }

        .rows {
            width: auto;
            float: left;
            padding-right: 30px;
            margin-right: 5%;
        }

            .rows > div, .colours > div {
                margin-bottom: 5px;
                text-align: right;
                width: 100%;
                position: relative;
            }

        .colours {
            float: left;
        }

            .colours > div > div {
                /*float: left;*/
                width: 20px;
                /*margin-right: 10px;*/
                padding: 5px;
                margin-bottom: 5px;
                border: 3px solid;
                border-radius: 15px;
                position: relative;
                background-color: black;
                float: left;
                margin-right: 30%;
            }

                .colours > div > div:hover {
                    cursor: pointer;
                }

            .colours input {
                width: 13px;
                height: 13px;
                margin: auto;
                display: block;
            }

        #rightcontainer {
            float: left;
            padding: 0 5px;
            margin-right: -99%;
            width: 20vw;
        }

            #rightcontainer > div {
                margin-top: 5px;
                display: inline-block;
                width: auto;
                width: 100%;
                box-sizing: border-box;
            }

            #rightcontainer > #controls {
                visibility: hidden;
                /*float: left;*/
                /*padding: 5px;*/
                /*width: 100%;*/
            }

        #controls button {
            font-size: .85em;
            padding: 4px;
        }

        #chat_scroller {
            background-color: black;
            border-radius: 5px;
            padding: 5px;
            display: none;
            overflow-y: scroll;
            font-size: .9em;
        }

            #chat_scroller .aichat {
                font-size: .7em;
            }

            #chat_scroller .chatname {
                border-bottom: 1px solid;
            }

        #chat_input {
            width: auto;
            display: none;
        }

        body {
        }

        input[type=text], select {
            background-color: #99ccbb;
            border-top-color: #aec;
            border-left-color: #aec;
            border-bottom-color: #9cb;
            border-right-color: #9cb;
        }
    </style>
    <script src="/Scripts/jquery-1.10.2.min.js"></script>
    <script src="/Scripts/ai1.js"></script>
    <script src="/Scripts/jquery.signalR-2.1.2.min.js"></script>
    <script src="/signalr/hubs"></script>
    <script src="~/Scripts/howler.js"></script>

    <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>




    <script>


        // SIGNALR
        var myHub;
        var test;
        var keys = [];
        var keyconst = {};
        var const_surrender = 's';
        var const_won = 'w';
        var const_bomb = 'b';
        var maxcooldown = 80;
        var maxBombTime = 180;
        var localPlayerIds = [];
        keyconst.ctrl = [17, 16, 224]; // 91 behaves odd in win/chrome
        keyconst.z = [90];
        keyconst.x = [88];
        keyconst.enter = [13];

        function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getMinIndex(array) {
            var indexOfMaxValue = array.reduce((iMax, x, i, arr) => x < arr[iMax] ? i : iMax, 0);
            return indexOfMaxValue;
        }

        function getMaxIndex(array) {
            var indexOfMaxValue = array.reduce((iMax, x, i, arr) => x > arr[iMax] ? i : iMax, 0);
            return indexOfMaxValue;
        }

        function startLog(aid) {
            aiPlayersHostedLocally[aid].logLevel = 1;
            aiPlayersHostedLocally[aid].logContinuous = 1;
        }
        function logOnce(aid) {
            aiPlayersHostedLocally[aid].logLevel = 2;
            aiPlayersHostedLocally[aid].logContinuous = 0;
            return aiPlayersHostedLocally[aid];
        }
        function getThreatMsg(hate) {
            if (hate < 2)
                return 'Stay away from me {0}';
            if (hate < 3)
                return '{0} you are harshing my buzz';
            if (hate < 4)
                return 'Have at thee, {0}!';
            if (hate < 6)
                return '{0} prepare to be squashed!';
            return '{0}, &*#$%^!';
        }

        function getLikeMsg(hate) {
            if (hate > -1.5)
                return '{0}, you are OK';
            if (hate > -3)
                return '{0} there may be room for two in this galaxy';
            if (hate > -4.5)
                return '{0}, I like your style';
            return '{0} is the opposite of poop!';
        }
        function getHelpMsg(hate) {
            if (hate < 2.5)
                return 'Please stop it, {0}!';
            if (hate < 3.7)
                return '{0} is a bully';
            if (hate < 5)
                return 'Someone save me from {0}!';
            if (hate < 7)
                return '{0} is killing meeee';
            return '{0}, &*#$%^!';
        }
        function stopLogging() {
            for (aid in aiPlayersHostedLocally) {
                aiPlayersHostedLocally[aid].logLevel = 0;
                aiPlayersHostedLocally[aid].logContinuous = 0;
            }
        }

        function scrollBottom(el) {
            el.stop();
            el.animate({ scrollTop: el.prop("scrollHeight") - el.height() }, 1000);
        }

        function processCheatCode(pid, msg) {
            if (msg == 'loveme') {
                var ai;
                for (var i in aiPlayersHostedLocally) {
                    ai = aiPlayersHostedLocally[i];
                    ai.loversPlayer = pid;
                }
            }
        }

        function resize() {
            stage.canvas.width = window.innerHeight * 1.5;
            stage.canvas.height = window.innerHeight;
            //document.getElementById("PalCanvas").setAttribute('width', window.innerHeight * 1.5);
            //document.getElementById("PalCanvas").setAttribute('height', window.innerHeight);
            var swidth = document.getElementById("PalCanvas").width;
            var sheight = document.getElementById("PalCanvas").height;
            globalscale = 1;
            planetRadiusPixels = planetradiuspercent * globalscale * 10;

            $("#rightcontainer").css({ width: window.innerWidth - swidth - 10 })

            stage.scaleX = stage.scaleY = swidth / 1000;
            ybound = 1000 * sheight / swidth;
            xbound = 1000;

        }

        $(function () {

            $(".more_button").on("click", function () {
                $(this).closest(".more_container").find(".more").slideDown(200);
                $(this).slideUp(200);
            });

            myHub = $.connection.palconHub;

            myHub.client.playerJoined = function (newNumPlayers) {
                playSound(sound_land, 0, 0.5, .3);
                numPlayers = newNumPlayers;
                $("#playersLabel").html(numPlayers);

            }



            myHub.client.receiveChat = function (pid, msg) {
                if (aiPlayersHostedLocally.length > 0) {
                    processCheatCode(pid, msg);
                }
                var html = "<br/><span style='color:" + ownercolours[pid] + "'>"
                + msg + "</span>";
                $("#chat_scroller").append(html);
                scrollBottom($("#chat_scroller"));
            }

            myHub.client.joinSuccess = function (aGameId) {
                var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
                if (!isChrome) {
                    $('.chrome_warning').show();
                }
                $(".waitforsignalr").hide();
                gameId = aGameId;
                $("#btnStart").css('visibility', 'visible');
                showSettings();
                initChat();
                $(".colours input").on("change", function () {
                    console.log('picked');
                    myHub.server.sendColour(gameId, $("input[name='colour']:checked").val());
                });
            }

            myHub.client.checkReadyToStart = function () {
                console.log('server asking ready to start');
                myHub.server.clientReadyToStart(gameId).done(function () {
                    console.log('told server ready to start');
                });
                init();
            }

            myHub.client.receiveMap = function (myPlayerId, json, colours) {
                console.log(colours);
                ownerIndex = myPlayerId;
                localPlayerIds.push(ownerIndex);
                ownercolours = JSON.parse(colours);
                $("body").css("background-color", ownercolours[ownerIndex]);

                //console.log(json);

                var map = JSON.parse(json);

                // INIT GAME

                processGameBoard(map);
                for (idx in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[idx].init();
                }
                if (aiPlayersHostedLocally.length > 0) {
                    logOnce(0);
                }
                setTimeout(startTicker, 500);
                setupDragBoxEvents();
                window.addEventListener('resize', resize, false);

            }

            myHub.client.receiveCommands = function (json) {

                var obj = JSON.parse(json);
                //incomingCommands = obj.commands;
                if (obj.turnId == turnId + 1) {
                    incomingCommands = obj.commands;
                    turnId++;
                }
                else if (obj.turnId > turnId + 1) {
                    //alert('You seem to be out of sync with the rest of the players.  You can continue playing, but unexpected results might occur');

                    console.log('commands received in wrong order? ' + obj.turnId + ' ' + turnId);
                    backlogIncomingCommands[obj.turnId] = obj.commands;
                    turnId++; // seems like a whole set gets skipped for all players? - so just move on to next turn
                }
                else {
                    incomingCommands = obj.commands;
                    console.log('commands received in wrong order - shouldnt be possible');
                }

                doTick(); // if in background, ensure commands get processed soonish?
                //handleIncoming(incomingCommands);
            }

            myHub.client.receiveSettings = function (jsonstr) {
                console.log('received settings');
                settings = JSON.parse(jsonstr);
                fleetspeed = settings.speed / 10;
                growthrate = settings.growth / 900;
                neutralPlanetCost = settings.costs;
                attackRatio = settings.attack;
                minPlayers = settings.minPlayers;
                showSettings();
                test = settings;
            }

            $.connection.hub.start().done(function () {
                try {
                    myHub.server.joinGame();
                }
                catch (ex) {
                    alert(ex);
                }

                $(".colours > div > div").on("click", function () {
                    $(this).find("input").select();
                    $(this).find("input").prop('checked', true);
                });



                $(window).keydown(
                    function (e) {
                        keys[e.which] = true;

                        if (e.which == keyconst.x[0]) {
                            cancelRecurringOrders();
                        }
                        if (e.which == keyconst.z[0]) {
                            //e.preventDefault();
                        }
                    }
                );
                $(window).keyup(
                    function (e) {
                        keys[e.which] = false;
                        if (e.which == keyconst.z) {
                            //e.preventDefault();
                        }
                        if (e.which == keyconst.enter) {
                            sendChat();
                            document.getElementById("btnSettings").focus();
                            document.getElementById("PalCanvas").focus();
                        }
                    }
                );

            });

            var context;
            try {
                // Fix up for prefixing
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                context = new AudioContext();
            }
            catch (e) {
                alert('Web Audio API is not supported in this browser');
            }
            sound_conquer = new Howl({
                //src: ['/content/nff-timpani-low.wav'],
                src: ['/content/nff-bass-thud.wav']
            });
            sound_warning = new Howl({
                src: ['/content/nff-pick.wav'],
                volume: .2
            });
            sound_attack = new Howl({
                src: ['/content/nff-laser.wav']
            });
            sound_land = new Howl({
                src: ['/content/blop.mp3']
            });


            //var sound_conquer = new Howl({
            //    src: ['/content/nff-timpani-low.wav'],
            //    volume: 0.5
            //});
            //sound_conquer.play();
            //sound_conquer.stereo(0);

        });

        function initChat() {
            $("#chat_input").show();
            $("#chat_scroller").show();
            $("#chat_input").on("keyup", function (evt) {

            });
        }

        function sendChat(msg) {
            if (!msg) {
                msg = $("#chat_input").val();
                $("#chat_input").val('');
            }
            myHub.server.sendChat(gameId, ownerIndex, null, msg);

        }

        function sendFormattedChat(pid, topid, message) {
            myHub.server.sendChat(gameId, pid, topid, message);
        }

        function isPressed(which) {
            for (code in which) {
                if (keys[which[code]])
                    return true;
            }
        }

        function sendSettings() {
            var settings = {};
            settings.lethargy = $("#lethargy").val();
            settings.speed = $("#fleetspeed").val();
            settings.growth = $("#growthrate").val();
            settings.ppp = $("#ppp").val();
            settings.costs = $("#costs").val();
            settings.attack = $("#attack").val();
            settings.minPlayers = $("#minplayers").val();
            myHub.server.sendSettings(gameId, JSON.stringify(settings));
        }

        function showSettings() {
            $("#lethargy").val(settings.lethargy);
            $("#fleetspeed").val(settings.speed);
            $("#growthrate").val(settings.growth);
            $("#ppp").val(settings.ppp);
            $("#costs").val(settings.costs);
            $("#attack").val(settings.attack);
            $("#minplayers").val(settings.minPlayers);
        }

        function sendQueue(json) {
            myHub.server.sendCommands(gameId, JSON.stringify(json));
        }

        function startGame() {
            sendSettings(); // somebody could have joined since last settings change.
            myHub.server.tryStartGame(gameId)
            .done(function (result) {
                numPlayers = result;
                if (numPlayers > 0) {
                    console.log('server says numplayers: ' + numPlayers);

                    while (numPlayers < minPlayers) {
                        if (numPlayers >= 99) {
                            aiPlayersHostedLocally.push(new AI(numPlayers + 1));
                        }
                        else {
                            aiPlayersHostedLocally.push(new AI2(numPlayers + 1));

                        }

                        numPlayers++;
                        localPlayerIds.push(numPlayers);
                    }

                    var json = JSON.stringify(generateGameBoard());
                    myHub.server.sendMap(gameId, json, aiPlayersHostedLocally.length);

                }
            });

        }

        function newGame() {
            myHub.server.sendChat(gameId, "[has left to start a new game]");
            window.location.reload();
        }
        var _paused;
        function togglePause() {
            _paused = !_paused;
        }

        function sendSurrender() {
            queuedCommands.push(
                        {
                            owner: ownerIndex,
                            type: const_surrender
                        }
                       );
        }

        function playerWon(oid) {
            for (var i in planets) {
                p = planets[i];
                if (p.owner == oid && p.growth == 4) {
                    showExplosion(p.x, p.y, p.radius * 3, oid, 30, true);
                }
            }
        }

        function playerSurrendered(oid) {
            if (oid == ownerIndex) {
                clearHighlights();
                // TODO: clear percent bars
            }
            var f;
            var todelete = [];
            for (var i in fleets) {
                f = fleets[i];
                if (f.owner == oid)
                    todelete.push(f);
            }
            for (var i in todelete) {
                f = todelete[i];
                showExplosion(f.shape.x, f.shape.y, f.size, oid, 2, true);
                var idx = jQuery.inArray(f, fleets);
                fleets.splice(idx, 1);
                layers.paths.removeChild(f.path);
                layers.fleets.removeChild(f.shape);
            }
            var p;
            for (var i in planets) {
                p = planets[i];
                if (p.owner == oid) {
                    p.owner = 0;
                    onPlanetChangeOwner(p);
                    //showOrderStart(p.x, p.y, p.radius, oid);
                    showExplosion(p.x, p.y, p.radius * 3, oid, 3, true);
                }
            }
        }

        // CONFIGURABLE SETTINGS

        var ticksPerTurn = 10;
        var msPerTurn = 500;
        var settings = {};
        settings.growth = 100;
        settings.speed = 100;
        settings.lethargy = 0;
        settings.costs = 50;
        settings.attack = .8;
        settings.minPlayers = 4;
        settings.ppp = 20;

        var planetradiuspercent = 1.9;
        var planetRadiusPixels = 0;


        var numPlayers = 0;
        var gameId;

        // UI
        var highlights = [];
        var currentBombPlanet;

        var highlightedPlanets = [];



        var sendPercentBars = [];
        var sendDestPlanet;
        var sendPercent;
        var sendPercentDelta;
        var sendInProgress;

        var layers = {};


        var sound_conquer;
        var sound_attack;
        var sound_warning;

        var isDragging;
        var dragBox;
        var dragStartPlanet;
        var dragEndPlanet;

        function processMisc()
        {
            if (window.innerHeight  == screen.height)
            {
                $("#fullscreen_msg").hide();
            }
        }

        function processCooldowns()
        {
            var planet;
            for(var p in planets)
            {
                planet = planets[p];
                if (planet.cooldown)
                {
                    planet.cooldown--;
                    if (planet.cooldown < 0)
                        planet.cooldown = 0;
                    drawCooldown(planet);
                }
            }
        }

        function doBombTick() {
            if (currentBombPlanet) {
                currentBombPlanet.bombTicks += currentBombPlanet.bombTickDirection;
                if (currentBombPlanet.bombTicks > currentBombPlanet.targetBombTicks)
                {
                    currentBombPlanet.bombTickDirection = -1;
                }
                drawBombTicking(currentBombPlanet);
                if (currentBombPlanet.bombTicks <= 0) {
                    stage.removeChild(currentBombPlanet.bombTickTargetShape);
                    stage.removeChild(currentBombPlanet.bombTickShape);
                    queuedCommands.push(
                        {
                            owner: ownerIndex,
                            from: currentBombPlanet.index,
                            type: const_bomb
                        }
                       );
                    onHighlightChange();
                }
            }
        }
        function onHighlightChange() {
            if (highlightedPlanets.length == 1 && !currentBombPlanet) {
                drawBomb(highlightedPlanets[0]);
                //currentBombPlanet = highlightedPlanets[0];
            }
            else {
                for (var idx in highlightedPlanets) {

                    var p = highlightedPlanets[idx];
                    if (p != currentBombPlanet) {
                        clearBombUi(p);
                    }
                }
            }
        }

        function clearHighlights() {
            var p;
            var toUnHighlight = [];
            for (var idx in highlightedPlanets) {
                p = highlightedPlanets[idx];
                toUnHighlight.push(p);
            }
            for (var idx in toUnHighlight) {
                p = toUnHighlight[idx];
                unHighlightPlanet(p);
            }
            onHighlightChange();
        }

        function clearBombUi(p) {
            if (p.bombIcon || p.bombTicks) {
                stage.removeChild(p.bombIcon);
                p.bombIcon = null;
                
                if (p.bombTickDirection > 0)
                {
                    stage.removeChild(p.bombTickShape);
                    stage.removeChild(p.bombTickTargetShape);
                    p.bombTickShape = null;
                    p.bombTickTargetShape = null;
                    p.bombTicks = 0;
                    p.bombTickDirection = null;
                    currentBombPlanet = null;
                }
            }
            
        }


        var highlightOn = true;
        function toggleHighlightBlink() {
            targetAlpha = .75;
            if (highlightOn)
                targetAlpha = .3;
            var p;
            for (var idx in highlightedPlanets) {
                p = highlightedPlanets[idx];
                createjs.Tween.get(p.highlight)
                    .to({ alpha: targetAlpha }, msPerTurn * .7);
            }
            highlightOn = !highlightOn;
        }


        function drawHighlight(planet) {
            planet.highlight = highlightShape(planet);
            layers.planets.addChild(planet.highlight);
        }
        function drawBomb(planet) {
            if (planet.bombIcon)
                return;
            planet.bombIcon = bombShape(planet);
            stage.addChild(planet.bombIcon);
            planet.bombIcon.addEventListener("mousedown", function (evt) {
                toggleBomb(planet);
            });
        }
        function drawBombTicking(planet) {
            if (planet.bombIcon && planet.bombTickDirection < 0)
            {
                stage.removeChild(planet.bombIcon);
                planet.bombIcon = null;
            }
            if (planet.bombTickTargetShape)
            {
                stage.removeChild(planet.bombTickTargetShape);
                planet.bombTickTargetShape = null;
            }
            if (planet.bombTickDirection > 0)
            {
                planet.bombTickTargetShape = tickingBombShape(planet, (planet.targetBombTicks + 1) * 1.0 / (maxBombTime + 1), true);
                stage.addChild(planet.bombTickTargetShape);
            }
            if (planet.bombTickShape)
                stage.removeChild(planet.bombTickShape);
            planet.bombTickShape = tickingBombShape(planet, (planet.bombTicks + 1) * 1.0 / (maxBombTime + 1), false);
            stage.addChild(planet.bombTickShape);

        }

        function onPlanetChangeOwner(p)
        {
            if (p == currentBombPlanet) {
                clearBombUi(p);
            }

            if (p.bombTicks && p.bombTickDirection > 0)
            {
                p.bombTicks = 0;
                stage.removeChild(planet.bombTickShape);
                planet.bombTickShape= null;
                stage.removeChild(planet.bombTickTargetShape);
                planet.bombTickTargetShape= null;
            }
           
            redrawPlanet(p);
            ensureHighlights();
        }


        function drawCooldown(planet) {
            if (planet.cooldownShape)
            {
                layers.planets.removeChild(planet.cooldownShape);
            }
            if (planet.cooldown > 0)
            {
                planet.cooldownShape = cooldownShape(planet,  (planet.cooldown + 2) / (maxcooldown * 1.0 + 2));
                layers.planets.addChild(planet.cooldownShape);
            }
        }


        var bombWarningPlanets = [];

        function startBombWarning(source, owner)
        {
            if (!source.bombWarningOwner)
            {
                source.bombWarningOwner = owner;
                source.bombWarningTicks = 4;
                bombWarningPlanets.push(source);
            }
            if (source == currentBombPlanet)
            {
                source.bombTicks = null;
                clearBombUi(currentBombPlanet);
                currentBombPlanet = null;
            }
        }
        var doWarningTickThisTurn = true;
        function processBombWarningTicks()
        {
            if (doWarningTickThisTurn)
            {
                var any = false;
                for (var idx in bombWarningPlanets)
                {
                    var planet = bombWarningPlanets[idx];
                    planet.bombWarningTicks--;
                    if (planet.bombWarningTicks == 0)
                    {
                        bombExplode(planet, planet.bombWarningOwner);
                    }
                    else
                    {
                        any = true;
                        showTextBlowup(planet.x, planet.y, 10, "#fff", 4, planet.bombWarningTicks)
                    }
                }
                if (any)
                    playSound(sound_warning, 500, 9, .2);
            }
            doWarningTickThisTurn = ! doWarningTickThisTurn;
        }

        function bombExplode(source, owner) {
            playSound(sound_conquer, source.x, .666, .1);
            bombWarningPlanets.splice(jQuery.inArray(source, bombWarningPlanets), 1);
            source.bombWarningOwner = null;
            source.bombWarningTicks = null;
            console.log('exploding-----------');
            var fleet;
            var planet;
            var maxDist = 80 + Math.sqrt(source.pop) * 6;
            var maxDistSquared = maxDist * maxDist;
            var maxPercent = Math.sqrt(source.pop) * 5;
            if (maxPercent > 100)
                maxPercent = 100;
            source.pop = 0.01;
            source.owner = 0;
            setTimeout(
                function(){showExplosion(source.x, source.y, maxDist/2, owner, 6, true);}, msPerTurn/2);
            var percent;
            var dist;
            
            for (var f in fleets) {
                fleet = fleets[f];
                distSquared = Math.pow(source.x - fleet.shape.x, 2) + Math.pow(source.y - fleet.shape.y, 2);
                console.log(distSquared);

                if (distSquared < maxDistSquared) {
                    dist = Math.sqrt(distSquared) - maxDist / 2;
                    console.log(dist);
                    percent = maxPercent * (maxDist / 2 - dist) / (maxDist / 2) + 50;
                    if (percent > 100)
                        percent = 100;
                    fleet.pop = fleet.pop * (1 - percent * .01);
                    if (percent == 100) {
                        doDeleteFleet(fleet);
                    }
                    else {
                        fleet.redrawScale(true);
                    }
                    showExplosion(fleet.shape.x, fleet.shape.y, percent / 10 + 4, fleet.owner, 9, false);
                }
            }

            //var maxDist = maxDist - 100;
            //var maxDistSquared = maxDist * maxDist;

            
            for (p in planets) {
                planet = planets[p];
                if (planet != source) {
                    distSquared = Math.pow(source.x - planet.x, 2) + Math.pow(source.y - planet.y, 2);
                    if (distSquared < maxDistSquared) {
                        dist = Math.sqrt(distSquared) - maxDist / 2 - planet.radius;
                        percent = maxPercent * (maxDist / 2 - dist) / (maxDist / 2);
                        if (percent > 100)
                            percent = 100;

                        planet.pop = planet.pop * (1 - percent * .01);
                        if (percent == 100) {
                            planet.owner = 0;
                            planet.pop = .01;
                            onPlanetChangeOwner(planet);
                        }
                        showExplosion(planet.x, planet.y, percent / 5 + 8, "#fff", 8, false);
                    }
                }
            }
            
            onPlanetChangeOwner(source);
            
        }
        function ensureHighlights() {
            var toUnhighlight = [];
            for (var idx in highlightedPlanets) {
                var p = highlightedPlanets[idx];
                if (p.owner != ownerIndex || p == currentBombPlanet) {
                    toUnhighlight.push(p);
                }
            }
            for (var idx in toUnhighlight) {
                var p = highlightedPlanets[idx];
                unHighlightPlanet(p);
            }
            onHighlightChange();
        }
        function toggleBomb(planet) {
            if (planet == currentBombPlanet)
            {
                planet.targetBombTicks += maxBombTime /4.0;
                if (planet.targetBombTicks > maxBombTime)
                    planet.targetBombTicks = maxBombTime /2.0;
            }
            else 
            {
                planet.bombTickDirection = maxBombTime / 20;
                planet.targetBombTicks = maxBombTime /2;
                planet.bombTicks = .1;
                currentBombPlanet = planet;
                drawBombTicking(planet);
                unHighlightPlanet(planet);
            }
        }
        function unHighlightPlanet(planet) {
            layers.planets.removeChild(planet.highlight);
            planet.highlight = null;
            highlightedPlanets.splice(jQuery.inArray(planet, highlightedPlanets), 1);
            if (planet != currentBombPlanet)
                clearBombUi(planet);
        }

        function highlightPlanet(planet) {
            if (planet != currentBombPlanet && ! planet.bombWarningTicks)
            {
                drawHighlight(planet);
                highlightedPlanets.push(planet);
            }
        }
        function setupDragBoxEvents() {
            stage.addEventListener("pressmove", function (evt) {
                var isRight = (evt.nativeEvent.buttons == 2);
                if (isRight)
                    return;
                if (!isDragging) {
                    isDragging = true;
                    if (!isPressed(keyconst.ctrl)) {
                        clearHighlights();
                    }
                    dragBox = new createjs.Shape();
                    dragBox.x = evt.stageX / stage.scaleX;
                    dragBox.y = evt.stageY / stage.scaleX;
                    var col = "#ffffff";
                    dragBox.graphics.setStrokeStyle(2 * globalscale, 'square', 'miter', 0, true);
                    dragBox.graphics.beginStroke(col);
                    dragBox.alpha = .4;
                    dragBox.graphics.drawRect(0, 0, 1, 1);
                    layers.paths.addChild(dragBox);
                }
                dragBox.scaleX = evt.stageX / stage.scaleX - dragBox.x;
                dragBox.scaleY = evt.stageY / stage.scaleX - dragBox.y;

                //stage.update(); //much smoother because it refreshes the screen every pixel movement instead of the FPS set on the Ticker
            });

            stage.addEventListener("stagemouseup", stagePressUp);
        }

        function stagePressUp(evt) {

            var isRight = (evt.nativeEvent.buttons == 2);
            if (isRight)
                return;
            if (isDragging) {

                isDragging = false;

                layers.paths.removeChild(dragBox);
                var p;
                var x1 = Math.min(dragBox.x, dragBox.x + dragBox.scaleX);
                var x2 = Math.max(dragBox.x, dragBox.x + dragBox.scaleX);
                var y1 = Math.min(dragBox.y, dragBox.y + dragBox.scaleY);
                var y2 = Math.max(dragBox.y, dragBox.y + dragBox.scaleY);
                for (var idx in planets) {
                    p = planets[idx];
                    if (p.owner == ownerIndex && p.highlight == null) {
                        var distFromStartSquared = Math.pow(p.x - dragBox.x, 2) + Math.pow(p.y - dragBox.y, 2);
                        if (distFromStartSquared < p.radius * p.radius) {
                            highlightPlanet(p);
                        }
                        else if (p.x > x1 && p.x < x2) {
                            if (p.y > y1 && p.y < y2) {
                                highlightPlanet(p);
                            }
                        }
                    }


                }
                onHighlightChange();
            }
            stage.update(); //much smoother because it refreshes the screen every pixel movement instead of the FPS set on the Ticker
            evt.bubbles = true;

            return true;
        }

        var sendPercentAlpha = .6;
        function startSendPercentBar(destPlanet) {
            if (!highlightedPlanets.length)
                return;
            sendDestPlanet = destPlanet;
            sendPercentDelta = 4;
            sendPercent = 0;
            var highlightedPlanet;
            for (var idx in highlightedPlanets) {
                var sendPercentBar = new createjs.Shape();
                layers.planets.addChild(sendPercentBar);

                highlightedPlanet = highlightedPlanets[idx];
                sendPercentBar.graphics.setStrokeStyle(7 * globalscale, 'square', 'miter', 0, true);
                //sendPercentBar.graphics.setStrokeDash([1, 10*globalscale], 0);
                sendPercentBar.alpha = sendPercentAlpha;
                var col = ownercolours[ownerIndex];
                if (isPressed(keyconst.z)) {
                    col = "#fff";
                }
                sendPercentBar.graphics.beginStroke(col);

                drawSurfacePath(highlightedPlanet, destPlanet, sendPercentBar);

                sendPercentBar.scaleX = sendPercentBar.scaleY = 0;
                sendPercentBar.fromPlanet = highlightedPlanet;
                layers.planets.addChild(sendPercentBar);
                sendPercentBars.push(sendPercentBar);
            }
            sendInProgress = true;
        }

        function cancelSend() {
            for (var idx in sendPercentBars) {
                layers.planets.removeChild(sendPercentBars[idx]);
            }
            sendPercentBars = [];
            sendInProgress = false;

        }

        function tryCreateCommand(fromPlanet, toPlanet, sendPercent, owner) {
            if (toPlanet != fromPlanet && ! fromPlanet.cooldown) {
                var pop = Math.round(fromPlanet.pop / 100 * sendPercent);

                if (pop >= 1) {
                    queuedCommands.push(
                        {
                            owner: owner,
                            pop: pop,
                            from: fromPlanet.index,
                            to: toPlanet.index
                        }
                       );
                    showOrderStart(fromPlanet.x, fromPlanet.y, fromPlanet.radius, owner);
                }
                return true;
            }
            else {
                return false;
            }
        }

        function doSend() {
            //stage.removeChild(sendPercentBar);
            var planet = sendDestPlanet;
            if (sendPercent > 95)
                sendPercent = 105; // clearly they want to just send everyone
            if (sendPercent < 10)
                sendPercent = 10;
            for (var idx in highlightedPlanets) {
                var highlightedPlanet = highlightedPlanets[idx];
                tryCreateCommand(highlightedPlanet, planet, sendPercent, ownerIndex);

                if (isPressed(keyconst.z)) {
                    console.log('creating recurring order');
                    recurringOrders.push(new RecurringOrder(highlightedPlanet, planet, sendPercent));
                }
            }
            cancelSend();
        }

        function updateSendProgress() {
            sendPercent += sendPercentDelta;
            if (sendPercent > 100 || sendPercent < 0) {
                sendPercent = sendPercent - sendPercentDelta;
                sendPercentDelta = 0 - sendPercentDelta;
            }
            var sendPercentBar;
            for (var idx in sendPercentBars) {
                sendPercentBar = sendPercentBars[idx];
                sendPercentBar.scaleX = sendPercentBar.scaleY = sendPercent / 100;
                if (sendPercentBar.fromPlanet.cooldown > 0)
                {
                    sendPercentBar.hiddenx = true;
                    sendPercentBar.tween = createjs.Tween.get(sendPercentBar);
                    sendPercentBar.tween.to({ alpha: 0.01 }, msPerTurn * 2 , createjs.Ease.quintOut);
                    if (sendPercentBars.length == 1)
                    {
                        cancelSend();
                    }
                }
                else if (sendPercentBar.hiddenx)
                {
                    sendPercentBar.hiddenx = false;
                    sendPercentBar.tween.to({ alpha: sendPercentAlpha}, msPerTurn * 1 , createjs.Ease.quintOut);
                    console.log('showing');
                }

            }
            if (sendPercent > 90) {

            }
            //stage.update();
        }

        // ENTITIES

        function RecurringOrder(from, to, percent) {
            this.lastExec = turnId;
            this.intervalTurns = 30;
            this.from = from;
            this.to = to;
            this.percent = percent;
            //this.amount = amount;
            this.shape = recurringPath(this);
            layers.paths.addChild(this.shape);
        }

        function Planet(growth, x, y, pop, owner) {
            this.index = planets.length;
            this.x = x;
            this.y = y;
            this.cooldown = 0;
            this.pop = pop;
            this.owner = owner;
            this.growth = growth;
            this.radius = Math.sqrt(growth) * planetRadiusPixels;   // pixels
            this.shape = planetShape(this.radius, x, y, owner);
            this.fillupContainer = new createjs.Container();
            this.label = planetLabel(this);
            this.fullpop = growth * 100;
            this.highlight = null;
            //layers.planets.addChild(this.shape);
            //layers.planets.addChild(this.label);
            var planet = this;
            drawPlanet(planet);
            var clickable = planetClickableShape(this);
            stage.addChild(clickable);

            clickable.addEventListener("click", function (evt) {
                console.log(evt);
                var isRight = (evt.nativeEvent.button == 2);
                if (isRight) {
                    if (sendInProgress)
                        doSend();
                }
            });

            clickable.addEventListener("mouseout", function (evt) {
                if (sendInProgress)
                    cancelSend();
            });


            clickable.addEventListener("mousedown", function (evt) {

                var isRight = (evt.nativeEvent.buttons == 2);
                if (isRight) {
                    if (sendInProgress) {
                        // something went wrong. prev send failed to cancel on mouseup.
                        cancelSend();
                    }
                    if (highlightedPlanets.length && (highlightedPlanets.length > 1 || planet.highlight == null)) {
                        startSendPercentBar(planet);
                    }
                }
                else {
                    if (planet.owner == ownerIndex) {
                        if (!isPressed(keyconst.ctrl)) {
                            clearHighlights();
                        }
                        if (planet.highlight == null) {
                            highlightPlanet(planet);
                        }
                        else {
                            unHighlightPlanet(planet);
                        }
                        onHighlightChange();
                    }

                }
            });

        }

        function Fleet(pop, startPlanet, destination, owner) {
            this.distToGo = 9999;
            this.pop = pop;
            this.owner = owner;
            this.destination = destination;
            var xdist = destination.shape.x - startPlanet.shape.x;
            var ydist = destination.shape.y - startPlanet.shape.y;
            var angle = Math.atan(ydist / xdist);
            if (xdist < 0) {
                angle = angle - Math.PI;
                //this.dx = 0 - this.dx;
                //this.dy = 0 - this.dy;
            }
            this.dx = globalscale * Math.cos(angle) * fleetspeed / ticksPerTurn;
            this.dy = globalscale * Math.sin(angle) * fleetspeed / ticksPerTurn;

            this.shape = fleetShape(Math.sqrt(pop), startPlanet.shape.x, startPlanet.shape.y, owner, angle);
            this.distMidToFront = 1.5;
            this.path = fleetPath(startPlanet, destination, owner);
            this.size = Math.sqrt(pop);
            this.popLandPerTurn = Math.round(this.pop / 10) + 1;
            this.ticksToNextLanding = null;
            layers.fleets.addChild(this.shape);
            layers.paths.addChild(this.path);
            //stage.setChildIndex(this.shape, 3);
            //layers.planets.setChildIndex(this.path, 1);

            this.redrawScale = function (immediate) {
                this.size = Math.sqrt(pop);
                var tween = createjs.Tween.get(this.shape, { useTicks: true });
                this.gameScale = globalscale * Math.sqrt(this.pop) * .7 + 1.5;
                time = 0;
                if(!immediate)
                    time =ticksPerTurn;
                tween.to({ scaleX: this.gameScale, scaleY: this.gameScale }, time);
                //this.shape.scaleX = this.shape.scaleY = globalscale * Math.sqrt(this.pop) * .7 + 1.5;
            }
            this.redrawScale();
        }


        // COMMS WITH SERVER
        var recurringOrders = [];
        var queuedCommands = [];
        var incomingCommands = null;
        var backlogIncomingCommands = [];
        function handleIncoming(commands) {
            var c;
            for (idx in commands) {
                c = commands[idx];
                if (c.type == const_bomb) {
                    startBombWarning(planets[c.from], c.owner);
                }
                if (c.type == const_surrender) {
                    playerSurrendered(c.owner);
                }
                else if (c.type == const_won) {
                    playerWon(c.owner);
                }
                else {
                    // default command: send fleet
                    var fromPlanet = planets[c.from];
                    var toPlanet = planets[c.to];
                    var pop = c.pop;
                    if (pop > fromPlanet.pop)
                        pop = Math.round(fromPlanet.pop - .5);
                    if (pop > 0 && fromPlanet.owner == c.owner) {
                        var f = new Fleet(pop, fromPlanet, toPlanet, c.owner);
                        fleets.push(f);
                        fromPlanet.pop -= pop;

                        if (toPlanet.owner == ownerIndex && fromPlanet.owner != ownerIndex) {

                            var rate = 1.7 - Math.sqrt(pop) / 10;
                            if (rate < .7)
                                rate = .7;
                            var volume = Math.sqrt(pop + 10) / 20 - .15;
                            if (volume > .5)
                                volume = .5;
                            playSound(sound_warning, fromPlanet.x, rate, volume);
                        }
                        for (var a in aiPlayersHostedLocally) {
                            aiPlayersHostedLocally[a].processFleetAttack(f);
                        }
                        var cooldown = Math.sqrt(c.pop + 15) * maxcooldown / 30;
                        if (cooldown > maxcooldown)
                            cooldown = maxcooldown;
                        fromPlanet.cooldown = cooldown;
                    }
                    else {
                        console.log('no pop? or planet changed hands since command sent?');
                    }
                }
            }
            incomingCommands = null;

            if (backlogIncomingCommands[turnId + 1]) {
                incomingCommands = backlogIncomingCommands[turnId + 1];
                turnId++;
            }


        }

        // GAME TIMING AND MECHANICS


        var tickInTurn = 0;
        var timeStartTurn = 0;
        var turnId = 0;

        var planets = [];
        var fleets = [];
        var distanceMatrix = []; // for AI's
        var distanceMatrixSumInverts = [];
        var stage;
        var globalscale;
        var xbound, ybound;
        var ownercolours = ['#dddddd', '#ffd400', '#ff6688', '#00eeee', '#50f050', '#8899ff', '#ff00ff', '#aacc00', '#ffffff'];

        var ownerIndex = null;

        function newScaledShape() {
            var shape = new createjs.Shape();
            shape.scaleX = globalscale;
            shape.scaleY = globalscale;
            return shape;
        }

        function planetLabel(planet) {
            var col = ownercolours[planet.owner];
            var txt = new createjs.Text("_", "bold 14px arial", col);
            txt.scaleX = globalscale;
            txt.scaleY = globalscale;
            txt.shadow = new createjs.Shadow("#000000", 0, 0, 3);
            return txt;
        }



        function planetShape(size, x, y, owner) {

            var shape = new createjs.Container();
            var strokeWidth = 2 * globalscale;
            var isize = size - strokeWidth;
            var col = ownercolours[owner];
            var circle = new createjs.Shape();
            shape.addChild(circle);
            circle.graphics.setStrokeStyle(strokeWidth);
            circle.graphics.beginStroke(col);
            circle.graphics.beginRadialGradientFill([ownercolours[owner], "#000"], [0, 1],
            0, 0, isize,
             isize * .3 + globalscale, isize * .3 + globalscale, isize * 1.2).drawCircle(0, 0, isize);
            circle.x = 0;
            circle.y = 0;
            var plain = new createjs.Shape();
            plain.graphics.beginFill(col).drawCircle(0, 0, isize - strokeWidth + .5 * globalscale);
            plain.alpha = .1;
            var circle2 = new createjs.Shape();
            var size2 = isize - strokeWidth + .5 * globalscale;
            circle2.alpha = .3;
            circle2.graphics.beginRadialGradientFill([ownercolours[owner], "#000"], [0, 1],
            0, 0, size2,
             size2 * .4 + globalscale, size2 * .4 + globalscale, size2 * 1.1).drawCircle(0, 0, size2);
            //circle2.graphics.beginFill(col).drawCircle(0, 0, isize - strokeWidth+.5*globalscale);

            shape.addChild(circle2);
            shape.addChild(plain);
            shape.x = x;
            shape.y = y;

            //circle.graphics.beginRadialGradientFill(["#000", ownercolours[owner], "#fff"], [0, 1,2], size/2, size/2, 0, size, size, size).drawCircle(size/2,size/2,size*.7);
            //circle.graphics.beginRadialGradientFill(["#000", ownercolours[owner]], [0, 1], size *.3, size *.3, size*.7, size/2, size/2, size*.8).drawCircle(size *.4, size *.4, size * .6);
            //            circle.graphics.beginRadialGradientFill(["#0f0", "#000"], [0, 1], 0-isize*.4, 0-isize*.4, isize, isize*.4, isize*.4,isize*1.4).drawCircle(0,0,size);


            return shape;
        }

        function planetFillup(planet) {
            var container = new createjs.Container();
            var col = ownercolours[planet.owner];
            var shape = new createjs.Shape();
            var line = new createjs.Shape();
            //shape.scaleX = shape.scaleY = 1;
            var size = planet.radius - 2 * globalscale
            var y = size * (1 - Math.min(2, (planet.pop * 2 / planet.fullpop))) + globalscale;
            shape.graphics.beginLinearGradientFill(["transparent", col, col, "transparent"], [0, .01, .2, .6], 0, y - 1 * globalscale, 0, y + size * 2);
            //shape.graphics.beginFill(ownercolours[planet.owner]);
            shape.graphics.drawCircle(0, 0, planet.radius - 1 * globalscale);
            shape.graphics.endFill();
            if (y > 0 - size) {
                line.graphics.setStrokeStyle(1, 'butt', 'round', 0);
                line.graphics.beginStroke(col)
                line.graphics.moveTo(0 - Math.sqrt(size * size - y * y), y);
                line.graphics.lineTo(Math.sqrt(size * size - y * y), y);
            }
            container.x = planet.x;
            container.y = planet.y;
            shape.alpha = .5;
            container.addChild(shape);
            container.addChild(line);
            return container;
        }

        function planetClickableShape(planet) {
            var circle = new createjs.Shape();
            //circle.graphics.setStrokeStyle(3 * globalscale);
            circle.graphics.beginFill(ownercolours[planet.owner])
            .drawCircle(0, 0, planet.radius + 5);
            circle.alpha = .01;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function tickingBombShape(planet, fraction, isSetup) {
            var circle = newScaledShape();
            var width = 4 * globalscale;
            var stroke = 3;

            if (isSetup)
            {
                circle.alpha = 1;
                width = 1 * globalscale;
                stroke = 1;
            }
            else
            {
                circle.alpha = 1;
            }
            circle.graphics.setStrokeStyle(width)
                .setStrokeDash([stroke*globalscale, (5-stroke)*globalscale], 0)
                .beginStroke("#fff")
            //circle.graphics.beginStroke("#FFF")
                .arc(0, 0, planet.radius * 1.1, 0, 0 - fraction *  Math.PI * 2, true);
            //circle.graphics.setStrokeStyle(1.5 * globalscale);
            //circle.graphics.beginStroke("#fff").drawCircle(0, 0, planet.radius + width/2);
            
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }
        
        function cooldownShape(planet, fraction) {
            var circle = newScaledShape();
            var width = 5 ;
            circle.graphics.setStrokeStyle(width * globalscale)
                .setStrokeDash([4*globalscale, 1*globalscale], 0)
                .beginStroke(ownercolours[planet.owner])
                .arc(0, 0, planet.radius - width, 0, fraction *  Math.PI * 2);
            circle.alpha = 1;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function planetClickableShape(planet) {
            var circle = new createjs.Shape();
            //circle.graphics.setStrokeStyle(3 * globalscale);
            circle.graphics.beginFill(ownercolours[planet.owner])
            .drawCircle(0, 0, planet.radius + 5);
            circle.alpha = .01;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function bombShape(planet) {
            var container = new createjs.Container();
            var circle = newScaledShape();
            var clickable = newScaledShape();
            container.addChild(circle);
            circle.x = planet.x + planet.radius  + 6 ;
            circle.y = planet.y - planet.radius  + 6 ;
            clickable.x = circle.x;
            clickable.y = circle.y;
            clickable.alpha = .01;
            clickable.graphics.beginFill(ownercolours[planet.owner])
                .drawCircle(0, 0, 6);
            var width = 2 * globalscale;
            circle.graphics.setStrokeStyle(width)
                .beginStroke('#ccc')
                .beginFill('#777')
                .drawCircle(0, 0, 5)
                .endFill()
                .setStrokeStyle(2 * globalscale)
                .beginStroke("#fff")
                .moveTo(-4, -4)
                .lineTo(-6, -9);
            return circle;
        }

        function highlightShape(planet) {
            var col = [ownercolours[ownerIndex]];
            var circle = new createjs.Shape();
            var width = 11 * globalscale;
            circle.graphics.setStrokeStyle(width);
            circle.graphics.beginRadialGradientStroke(["transparent", "#fff", col, "transparent"], [0, .2, .3, 1],
                0, 0, planet.radius,
             0, 0, planet.radius + 11 * globalscale)
            //circle.graphics.beginStroke("#FFF")
            .drawCircle(0, 0, planet.radius + 5 * globalscale);
            //circle.graphics.setStrokeStyle(1.5 * globalscale);
            //circle.graphics.beginStroke("#fff").drawCircle(0, 0, planet.radius + width/2);
            circle.alpha = .66;
            circle.x = planet.x;
            circle.y = planet.y;
            return circle;
        }

        function fleetShape(size, x, y, owner, angle) {
            var col = ownercolours[owner];
            var container = new createjs.Container();
            var shape = new createjs.Shape();
            var shapeNoShadow = new createjs.Shape();
            container.addChild(shape);
            container.addChild(shapeNoShadow);

            //shape.graphics.setStrokeStyle(1 + .1 * scale * globalscale, 'butt', 'round', 0, true);
            //shape.graphics.beginStroke(col);
            shape.graphics.beginFill(col);

            shape.graphics.moveTo(1, 2);
            shape.graphics.lineTo(-.7, .3);
            shape.graphics.lineTo(-.5, 0);

            shape.graphics.lineTo(1, .5);
            shape.graphics.lineTo(2.5, 0);
            shape.graphics.lineTo(2.7, .3);
            shape.graphics.lineTo(1, 2);

            shape.graphics.endStroke();
            shape.graphics.endFill();
            shape.graphics.beginRadialGradientFill([col, "#000"], [0, 1],
            -5, 0, 7, -5.5, 0, 4).drawEllipse(0, 0, 2, 3);

            shape.shadow = new createjs.Shadow("#000000", 3 + size * globalscale / 10, 3 + size * globalscale / 10, globalscale * (10 + size));

            shapeNoShadow.graphics.beginLinearGradientFill([col, "#fff"], [1, 0], -1, 2.5, 1.5, 2.5)
            //shape.graphics.beginRadialGradientFill(["#000","#000", col,"#fff"], [0,.4,.8, 1],
            //1, 2.2, 2,
            // 1.3, 2.5, .02).drawEllipse(.4, 1.5, 1.2, 1.7);
            .drawEllipse(.4, 1.2, 1.2, 1.2);
            //.drawEllipse(-10, -10, 20, 40);




            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff",col, "#000000"], [0,.3,.3,.45, 1], 4, -1, -2, 3);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff", col, "#000000"], [0, 0,0, .35, 1], 2.5, .5, -3, 2);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.beginLinearGradientFill([col,col, "#ffffff", col, "#000000"], [0, .1,.1, .25, 1], 3, 0, -2, 0);
            //shape.graphics.moveTo(0, 1);
            //shape.graphics.lineTo(2, 0);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(0, 1);

            //shape.graphics.endFill();
            //shape.graphics.setStrokeStyle(1 + .01 * scale, 'butt', 'round', 0, true);
            //shape.graphics.beginStroke(col);
            //shape.graphics.moveTo(2, 0);
            //shape.graphics.lineTo(0, 3);
            //shape.graphics.lineTo(-2, 0);
            //shape.graphics.lineTo(2, 0).lineTo(0, 3);


            container.regX = 1;
            container.regY = 1.5;
            container.x = x;
            container.y = y;
            container.rotation = angle * 180 / Math.PI - 90;
            if (container.rotation < 0)
                container.rotation += 360;
            //shape.rotation += 0 - 90 - angle * 180/ Math.PI;
            return container;
        }

        function drawSurfacePath(planet1, planet2, shape) {
            var x = planet1.x;
            var y = planet1.y;
            var xd = (planet2.x - x);
            var yd = (planet2.y - y);
            var dist = Math.sqrt(xd * xd + yd * yd);
            var startRadProportion = planet1.radius / dist;
            var startCuttoffX = xd * startRadProportion;
            var startCuttoffY = yd * startRadProportion;
            x = x + startCuttoffX;
            y = y + startCuttoffY;
            var endRadProportion = planet2.radius / dist;
            xd = xd - xd * endRadProportion - startCuttoffX;
            yd = yd - yd * endRadProportion - startCuttoffY;
            shape.graphics.moveTo(0, 0);
            shape.graphics.lineTo(xd, yd);
            shape.x = x;
            shape.y = y;

        }

        function recurringPath(recurring) {
            var shape = new createjs.Shape();
            shape.alpha = .4;
            width = (2 + recurring.percent * .04) * globalscale;
            shape.graphics.setStrokeStyle(width, 0, 0, 0, true);
            //shape.graphics.setStrokeDash([2 * globalscale, 2 * globalscale], 0);
            shape.graphics.beginStroke("#ffffff");

            drawSurfacePath(recurring.from, recurring.to, shape);
            return shape;

        }

        function fleetPath(p1, p2, owner, width) {
            if (!width)
                width = 3 * globalscale;
            var shape = new createjs.Shape();
            shape.graphics.setStrokeStyle(width, 0, 0, 0, true);
            shape.graphics.setStrokeDash([2 * globalscale, 2 * globalscale], 0);
            shape.graphics.beginStroke(ownercolours[owner]);
            drawSurfacePath(p1, p2, shape);
            //shape.graphics.moveTo(0, 0);
            //shape.graphics.lineTo(x2 - x1, y2 - y1);
            shape.alpha = .4;
            //shape.x = x1;
            //shape.y = y1;
            return shape;
        }

        function bg() {
            var bg = new createjs.Shape();
            //bg.scaleX = 1;
            //bg.scaleY = 1;
            bg.graphics.beginFill("#000000").drawRect(0, 0, xbound, ybound);
            bg.x = 0;
            bg.y = 0;
            return bg;
        }
        var numBigPlanets = 0;
        function processGameBoard(planetArray) {
            for (idx in planetArray) {
                var j = planetArray[idx];
                var p = new Planet(j.growth, j.x * globalscale * 10, j.y * globalscale * 10, j.pop, j.owner);
                planets.push(p);
            }
            distanceMatrix = [];
            distanceMatrixSumInverts = [];
            var j;
            for (idx in planets) {

                var p = planets[idx];
                if (p.growth == 4) numBigPlanets++;
                var arr = [];
                var sumInverted = 0;
                for (j in planets) {

                    if (idx != j) {
                        var p2 = planets[j];
                        var distCentres = Math.sqrt(Math.pow(p.shape.x - p2.shape.x, 2) + Math.pow(p.shape.y - p2.shape.y, 2));
                        var distance = distCentres - p2.radius;
                        //var distPercent = (distCentres - p.shape.radius) * 100 / xbound;

                        arr.push({ planetId: p2.index, dist: distance });
                        sumInverted += 1 / (distance + 30);

                    }
                }
                arr = arr.sort(function (a, b) {
                    return a.dist < b.dist ? -1 : 1;
                });
                arr = arr.slice(0, 10);
                distanceMatrix.push(arr);
                distanceMatrixSumInverts.push(sumInverted);
            }

        }


        function generateGameBoard(isRetry) {
            function overlap(obj, minDist) {
                var gap = minDist;
                if (!minDist)
                    gap = 1;
                var p;
                var distCentresSquared;
                var distFilledUpSquared;
                for (idx in planetArray) {
                    p = planetArray[idx];
                    distCentresSquared = Math.pow(obj.x - p.x, 2) + Math.pow(obj.y - p.y, 2);
                    distFilledUpSquared = Math.pow(p.radius + obj.radius + gap, 2);
                    if (distCentresSquared < distFilledUpSquared)
                        return true;
                    //if (p.x - p.radius - gap < obj.x + obj.radius && p.x + p.radius + gap > obj.x - obj.radius) {
                    //    if (p.y - p.radius - gap < obj.y + obj.radius && p.y + p.radius + gap > obj.y - obj.radius) {
                    //        return true;
                    //    }
                    //}
                }
                return false;
            }

            planetArray = [];
            var newPlanet;
            var minDistBetweenPlayers = 100 / (numPlayers + 1);
            var bigpop = 100;
            for (i = 1; i <= numPlayers; i++) {
                var growth = 4;
                var canadd = false;
                var tries = 0;

                while (!canadd) {
                    var radius = Math.sqrt(growth) * planetradiuspercent;
                    newPlanet =
                    {
                        owner: i,
                        x: Math.random() * (100 - radius * 2) + radius,
                        y: Math.random() * (100 / xbound * ybound - radius * 2) + radius,
                        pop: bigpop,
                        growth: growth,
                        radius: radius
                    };
                    canadd = !overlap(newPlanet, minDistBetweenPlayers);
                    if (!canadd) {

                    }
                    tries++;
                    if (tries > 10) {
                        minDistBetweenPlayers = minDistBetweenPlayers * .99;
                    }
                    if (tries > 100) {
                        if (isRetry) {
                            alert('can\'t find a place to add new starting planets.');
                            return;
                        }
                        else {
                            return generateGameBoard(true);
                        }
                    }
                }
                planetArray.push(newPlanet);
                //bigpop = 100;
            }
            var growth = 4;
            var extraCost = 20;
            var numNeutrals = 12 + (numPlayers + 1) * (settings.ppp / 10);
            if (numNeutrals > 100)
                numNeutrals = 100;
            var got = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
            for (i = 0; i < numNeutrals; i++) {
                if (i == 1) {
                    growth = 1;
                    extraCost = 0;
                }
                if (i * 2 >= numNeutrals)
                    growth = 2;
                var canadd = false;
                var tries = 0;
                while (!canadd) {
                    var radius = Math.sqrt(growth) * planetradiuspercent;
                    newPlanet =
                    {
                        owner: 0,
                        x: Math.random() * (100 - radius * 2) + radius,
                        y: Math.random() * (100 / xbound * ybound - radius * 2) + radius,
                        pop: growth * neutralPlanetCost / 4 + Math.random() * growth * neutralPlanetCost / 4 + extraCost,
                        growth: growth,
                        radius: radius
                    };
                    canadd = !overlap(newPlanet);
                    if (!canadd) {
                        tries++;
                    }

                    if (tries > 100) {
                        if (isRetry) {
                            return planetArray;
                        }
                        else {
                            return generateGameBoard(true);
                        }
                    }
                }
                var next = getMinIndex(got);
                //console.log(next);
                //newPlanet.owner = next;
                got[next] += newPlanet.pop + newPlanet.growth * 4;
                planetArray.push(newPlanet);

            }

            return planetArray;

        }

        function init() {
            $("#rightcontainer h3").hide();
            createjs.Touch.enable(stage, false, true);

            $("#pregame").hide();

            document.getElementById("PalCanvas").addEventListener('contextmenu', function (e) {
                if (e.button === 2) {
                    e.preventDefault();
                    return false;
                }
            }, false);


            $("body").css({ overflow: 'hidden' });
            //var planetsData = generateGameBoard();




            // code here.
            stage = new createjs.Stage("PalCanvas");
            resize();
            stage.enableMouseOver(10);
            stage.update();


            stage.addChild(bg());
            layers.planets = new createjs.Container();
            layers.paths = new createjs.Container();
            stage.addChild(layers.paths);
            stage.addChild(layers.planets);
            layers.fleets = new createjs.Container();
            stage.addChild(layers.fleets);

            // must be after setting globalscale and initing stage:
            //processGameBoard(planetsData);

            //var p = new Planet(1, 50, 50, 101.3, 0);
            //planets.push(p);
            //p = new Planet(2, 600, 140, 5, 1);
            //planets.push(p);
            //p = new Planet(4, 510, 210, 50, 0);
            //planets.push(p);

            //var f = new Fleet(15, planets[2], planets[1], 0);
            //fleets.push(f);

            //f = new Fleet(3, planets[1], planets[0], 1);
            //fleets.push(f);
            //f = new Fleet(80, planets[1], planets[2], 1);
            //fleets.push(f);

            playSound(sound_warning, xbound / 2, .5, .4);
        }

        function startTicker() {
            $("body").css('background-color', '#333');
            createjs.Ticker.setFPS(ticksPerTurn / msPerTurn * 1000);
            createjs.Ticker.addEventListener("tick", handleTick);
            timeStartTurn = new Date().getTime();
            myHub.server.sendCommands(gameId, '[]');
            $("#controls").css('visibility', 'visible');

            var p = planets[ownerIndex - 1];
            if (p.owner == ownerIndex) {
                showOrderStart(p.x, p.y, 100, ownerIndex);
                highlightPlanet(p);
            }
        }

        function updatePlanet(p) {

            if (p.owner > 0) {
                if (p.pop < p.fullpop) {
                    p.pop += p.growth * growthrate / ticksPerTurn;
                }

            }
            var isOverpopulated = p.pop > p.fullpop - 1; // 1 wiggle room for rounding because using test to check
            //var isOverpopulated = p.pop > p.fullpop - 1;
            var newText = Math.round(p.pop);

            if (newText != p.label.text) {
                if (isOverpopulated)
                    p.label.color = "#bbb"
                else
                    p.label.color = ownercolours[p.owner];
                p.label.text = newText;

                p.label.x = p.x - globalscale * p.label.getBounds().width / 2;
                p.label.y = p.y - globalscale * p.label.getBounds().height / 2;

                p.fillupContainer.removeChild(p.fillup);
                p.fillup = planetFillup(p);
                p.fillupContainer.addChild(p.fillup);
            }
        }

        function moveFleet(f, idx) {
            if (f != null) {
                f.distToGo = Math.sqrt(Math.pow((f.shape.x - f.destination.shape.x), 2) + Math.pow((f.shape.y - f.destination.shape.y), 2))
                 - f.destination.radius * globalscale
                 - f.distMidToFront * f.gameScale;

                if (f.distToGo < 0) {
                    //f.arrived = true;

                    if (f.ticksToNextLanding > 0) {
                        f.ticksToNextLanding--;
                    }
                    else {
                        land(f);
                        f.ticksToNextLanding = ticksPerTurn;
                    }
                    //fleets[idx] = null;

                }
                else {

                    f.shape.x += f.dx;
                    f.shape.y += f.dy;

                    //createjs.Tween.get(f.shape)
                    //.to({ x: f.shape.x + f.dx, y: f.shape.y + f.dy }, msPerTurn / ticksPerTurn);
                }
            }
        }

        function showOrderStart(x, y, radius, owner) {
            var circle = new createjs.Shape();
            circle.graphics.setStrokeStyle(8 * globalscale);
            circle.graphics.beginStroke(ownercolours[owner]).drawCircle(0, 0, radius - 3);
            circle.x = x;
            circle.y = y;
            circle.scaleX = globalscale;
            circle.scaleY = globalscale;
            circle.alpha = .7;
            layers.planets.addChild(circle);
            createjs.Tween.get(circle)
                    .to({ scaleX: 0, scaleY: 0 }, msPerTurn * 2);
            //                    .to({ scaleX: 1, scaleY: 1, alpha: 0 }, msPerTurn * 2, createjs.Ease.quintOut);

        }

        function showTextBlowup(x, y, size, col, timeScale, text) {
            if (!timeScale)
                timeScale = 1;
            var txt = new createjs.Text(text, "bold 14px arial", col);
            txt.x = x;
            txt.y = y;
            txt.scaleX = globalscale;
            txt.scaleY = globalscale;
            txt.regX = txt.getBounds().width / 2;
            txt.regY = txt.getBounds().height / 2 + 3;
            txt.shadow = new createjs.Shadow("#000000", 0, 0, 3);
            layers.planets.addChild(txt);
            var tween = createjs.Tween.get(txt);
            tween.to({ scaleX: size * globalscale, scaleY: size * globalscale, alpha: 0 }, msPerTurn * 2 * timeScale, createjs.Ease.quintOut);

        }

        function showExplosion(x, y, size, owner, timeScale, noBrightPatch) {
            if (!timeScale)
                timeScale = 1;
            var circle = new createjs.Shape();
            circle.graphics.setStrokeStyle((8 + size/3) * globalscale)
            .beginStroke(ownercolours[owner]).drawCircle(0, 0, 5 + size * 2);
            circle.x = x;
            circle.y = y;
            circle.scaleX = .1;
            circle.scaleY = .1;
            circle.alpha = 1;
            layers.fleets.addChild(circle);

            var tween = createjs.Tween.get(circle);
            if (!noBrightPatch) {
                tween.to({ scaleX: .3, scaleY: .3 }, msPerTurn * .15 * timeScale);
            }
            tween.to({ scaleX: 1, scaleY: 1, alpha: 0 }, msPerTurn * 2 * timeScale, createjs.Ease.quintOut);
        }

        function playSound(sound, x, rate, volume) {

            var pan = 0;
            if (xbound) {
                pan = x / xbound * 2 - 1;
            }
            if (!rate)
                rate = 1;
            if (!volume)
                volume = 1;
            sound._volume = volume;
            sound._stereo = pan;
            sound._rate = rate;
            var s = sound.play();
            sound.stereo(pan, s);
            sound.rate(rate, s);
            sound.volume(volume, s);
        }

        function redrawPlanet(p) {
            layers.planets.removeChild(p.shape);
            layers.planets.removeChild(p.label);
            p.fillupContainer.removeChild(p.fillup);
            drawPlanet(p);
        }

        function drawPlanet(p) {
            p.shape = planetShape(p.radius, p.x, p.y, p.owner);
            p.label = planetLabel(p);
            p.fillup = planetFillup(p);
            layers.planets.addChild(p.shape);
            p.fillupContainer.addChild(p.fillup);
            layers.planets.addChild(p.fillupContainer);
            layers.planets.addChild(p.label);
        }

        function land(f) {

            var deleteFleet;

            var p = f.destination;

            var landPop = Math.min(f.popLandPerTurn, f.pop);

            //sound calcs


            var volume = Math.sqrt(landPop + 10) / 10 - .3;
            if (volume > 1)
                volume = 1;
            var spotx = f.shape.x + Math.cos(Math.atan(f.dy / f.dx)) * Math.sign(f.dx) * f.distMidToFront * f.shape.scaleX;
            var spoty = f.shape.y + Math.sin(Math.atan(f.dy / f.dx)) * Math.sign(f.dx) * f.distMidToFront * f.shape.scaleX;

            if (f.owner != f.destination.owner) {
                // ATTACK

                var rate = 3 - 10 * landPop / (f.destination.pop + 10);
                if (rate < .5)
                    rate = .5;
                if (rate > 3)
                    rate = 3;

                showExplosion(spotx, spoty, f.shape.scaleX, f.owner, 1);

                var damage = landPop * attackRatio;


                if (f.destination.pop >= damage) {

                    playSound(sound_attack, p.x, rate / 2 + .25, volume * .35);



                    f.destination.pop -= damage;
                    f.pop -= landPop;

                    if (f.pop <= 0) {
                        deleteFleet = true;
                    }
                    else {
                        f.redrawScale();
                    }
                }
                else {



                    // CAPTURE PLANET AND TRANSFER REMAINING SHIPS
                    fleetLoss = f.destination.pop / attackRatio;
                    f.destination.pop = f.pop - fleetLoss;

                    showExplosion(p.x, p.y, p.radius * 3, p.owner, 2, true);
                    var ex = p.x;
                    var ey = p.y;
                    var er = p.radius * 3;
                    var fowner = f.owner;
                    setTimeout(function () {
                        showExplosion(ex, ey, er, fowner, 2, true);
                    }, 200);
                    for (var idx in highlightedPlanets) {
                        if (highlightedPlanets[idx] == p) {
                            unHighlightPlanet(p);
                        }
                    }
                    onHighlightChange();
                    p.owner = f.owner;
                    p.cooldown = 0.1;
                    onPlanetChangeOwner(p);

                    playSound(sound_conquer, p.x, 2 - p.growth * .25, .06);
                    deleteFleet = true;
                    if (p.growth == 4) {
                        var bigPlanetsStillNeeded = 0;
                        var pp;
                        for (var idx in planets) {
                            pp = planets[idx];
                            if (pp.growth == 4 && pp.owner != f.owner) {
                                bigPlanetsStillNeeded++;
                            }
                        }
                        if (localPlayerIds.indexOf(f.owner) > -1) {
                            if (bigPlanetsStillNeeded == 1) {
                                sendFormattedChat(f.owner, f.owner, '[{0} ONLY NEEDS ONE MORE BASE PLANET TO WIN!]');
                            }
                            else if (bigPlanetsStillNeeded == 0) {
                                sendFormattedChat(f.owner, f.owner, '[{0} HAS WON!]');
                                queuedCommands.push(
                                        {
                                            owner: f.owner,
                                            type: const_won
                                        }
                                   );
                            }
                        }
                    }
                }

            }
            else {
                var rate = 3 - 10 * landPop / (f.destination.pop + 10);
                if (rate < .5)
                    rate = .5;
                playSound(sound_land, p.x, rate, volume);
                showExplosion(spotx, spoty, f.shape.scaleX, f.owner, 1);
                f.destination.pop += landPop;
                f.pop -= landPop
                f.redrawScale();

                if (!f.landing) {
                    f.landing = true;
                    var tween = createjs.Tween.get(f.shape);
                    //targetx = (f.shape.x * 2 + f.destination.x) / 3;
                    //targety = (f.shape.y * 2 + f.destination.y) / 3;

                    ////showExplosion(targetx, targety, f.shape.scaleX, f.owner);
                    if (f.shape.rotation + Math.random() * 100 - 50 < 180)
                        rotate = 270 + Math.random() * 50 - 25;
                    else
                        rotate = 90 + Math.random() * 50 - 25;
                    if (rotate - f.shape.rotation > 360)
                        rotate -= 360;
                    if (rotate - f.shape.rotation < -360)
                        rotate += 360;
                    //var moreRotate = rotate + (rotate - f.shape.rotation) / 2;
                    tween.to({ rotation: rotate }, msPerTurn * 2, createjs.Ease.cubicInOut);


                    //setTimeout(function () {
                    //    layers.fleets.removeChild(f.shape);
                    //}, msPerTurn * 4)
                }

                if (f.pop <= 0) {
                    deleteFleet = true;
                }

            }


            if (deleteFleet) {
                doDeleteFleet(f);
            }
            layers.paths.removeChild(f.path);
        }

        function doDeleteFleet(fleet) {
            layers.fleets.removeChild(fleet.shape);
            var idx = jQuery.inArray(fleet, fleets);
            fleets.splice(idx, 1);
            layers.paths.removeChild(fleet.path);
        }

        function processRecurringOrders() {
            var idx;
            for (idx in recurringOrders) {
                // not perfect, but good enough:
                var o = recurringOrders[idx];
                if (o.from.owner != ownerIndex)
                    cancelRecurringOrder(o);
            }
            for (idx in recurringOrders) {
                var o = recurringOrders[idx];

                if (o.lastExec + o.intervalTurns <= turnId) {
                    tryCreateCommand(o.from, o.to, o.percent, ownerIndex);
                    o.lastExec = turnId;

                }
            }
        }

        function cancelRecurringOrder(o) {
            layers.paths.removeChild(o.shape);
            recurringOrders.splice(jQuery.inArray(o, recurringOrders), 1);
        }

        function cancelRecurringOrders() {


            for (var pi in highlightedPlanets) {

                var p = highlightedPlanets[pi];
                for (var idx = 0; idx < recurringOrders.length; idx++) {
                    var o = recurringOrders[idx];

                    if (o.from == p) {
                        cancelRecurringOrder(o);
                        idx--;
                    }
                }
            }

            //recurringOrders = [];
        }

        function doTick() {
            if (_paused)
                return;
            var a;
            var f;
            var p;

            tickInTurn++;

            if (tickInTurn == 2) {
                for (a in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[a].doTurn1();
                }
            }
            if (tickInTurn == 3) {
                for (a in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[a].doTurn2();
                }
            }
            if (tickInTurn == 4) {
                for (a in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[a].doTurn3();
                }
            }
            if (tickInTurn == 5) {
                for (a in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[a].doTurn4();
                }
            }
            if (tickInTurn == 6) {
                for (a in aiPlayersHostedLocally) {
                    aiPlayersHostedLocally[a].doTurnFinal();
                }
            }
            if (tickInTurn == 7) {
                processCooldowns();
            }
            if (tickInTurn == 8) {
                processBombWarningTicks();
                processMisc();
            }
            if (tickInTurn == 9) {
                toggleHighlightBlink();
            }
            if (tickInTurn == ticksPerTurn) {
                doBombTick();
            }
            if (tickInTurn >= ticksPerTurn) {
                // todo
                if (incomingCommands != null) {
                    // sneak in recurring orders just before sending:
                    processRecurringOrders();



                    tickInTurn = 0;
                    timeStartTurn = new Date().getTime();

                    sendQueue(queuedCommands);
                    queuedCommands = [];
                    handleIncoming(incomingCommands);


                }
                else if (tickInTurn == ticksPerTurn + 10) {
                    // still waiting. pause.
                    console.log('pausing....');
                }


            }
            else {
                for (var f in fleets) {
                    moveFleet(fleets[f], f);
                }
                for (var p in planets) {
                    updatePlanet(planets[p]);
                }

                var expectedTime = timeStartTurn + tickInTurn * msPerTurn / ticksPerTurn;
                var actualTime = new Date().getTime();
                var lag = actualTime - expectedTime;
                if (lag > 50) {
                    console.log('lagging by ' + lag + ' ms - catch up');
                    doTick();
                }

            }

        }

        function handleTick(event) {
            // Actions carried out each tick (aka frame)
            if (!event.paused) {
                // Actions carried out when the Ticker is not paused.

                doTick();
                if (sendInProgress)
                    updateSendProgress(); // do this regardless of game lag
                stage.update();
            }
        }


        // ======================= AI ==============================
        var aiPlayersHostedLocally = [];


        function AI2(ownerId) {
            this.timeRanges = [6, 12, 24];
            this.ownerId = ownerId;
            this.pdata = [];
            this.rallyPoints = [];
            this.myPlanets = [];
            this.mapWideDanger = 0;
            this.announceHateThreshhold = 2;
            this.announceLikeThreshhold = -1;
            this.loversPlayer = -1;
            function PlanetData(planet) {
                this.planet = planet;
                this.planetId = planet.index;
                this.owner = planet.owner;
                this.lastSent = -100;

                this.desirability = 0; // M, L, size
                this.influenceAddedThisStep = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                this.lastDidntAttack = -50;
                this.desirability = planet.growth;
                this.growthPerTurn = planet.growth * growthrate;
                this.setStartTurnVals = function () {
                    this.dependsonReinforcements = false;
                    this.influence = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                    this.owner = this.planet.owner;
                    this.aiInfluence = 0;
                    this.planetInfluence = 0;
                    this.otherInfluence = 0;
                    this.goodTarget = 0;
                    this.goodRallyPoint = 0;

                    this.influence[this.planet.owner] = this.planet.pop
                    if (this.planet.owner > 0) {
                        this.influence[this.planet.owner] += this.growthPerTurn * 10;
                    }
                    //if (this.influence[this.planet.owner] == 0) {
                    //    console.log('error 0 inf ' + this.planetId);
                    //}

                    this.aiMaxByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.planetMaxByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.oppositionByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.otherMaxByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);

                    this.aiActualByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.planetActualByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.otherActualByTime = Array.apply(null, Array(4)).map(Number.prototype.valueOf, 0);
                    this.actualByOwner = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                    this.safetyMargin = 0; // fleets, maxbytime [S]?, influence
                    this.want = 0; //
                    this.urgency = 0; // fleets, desirability, can keep
                    //this.excessPercent = 0;
                    this.sentThisTurn = false;
                }
            }


            this.init = function () {
                this.isDead = false;
                // call after planets and players created
                //this.persistentPlanetData = Array.apply(null, Array(planets.length));
                //for (var idx in this.persistentPlanetData)
                //                    this.persistentPlanetData[idx] = { lastSent: -10 };
                this.enmity = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, Math.random()*2 -1);

                this.attackPref = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 1);
                this.enmitySendRatio = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 1);
                this.might = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 1);
                this.numShips = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 1);
                this.stubbornChance = Math.random();
                this.planetData = [];
                for (var idx2 in planets) {
                    p = planets[idx2];
                    this.planetData.push(new PlanetData(p));
                }
            }

            this.processFleetAttack = function (f) {
                var p = this.planetData[f.destination.index];
                var effectiveOwner = p.effectiveOwner;
                this.log('effective owner: ' + effectiveOwner);
                conquerFactor = 1;
                if (effectiveOwner == f.owner)
                {
                    effectiveOwner = p.owner;
                    conquerFactor = .5;
                }
                if (effectiveOwner > 0 && effectiveOwner != f.owner && f.owner != p.owner) {
                    var effectivePop = p.actualByOwner[effectiveOwner];
                    var attackingPop = p.actualByOwner[f.owner];
                    var neededToTake = Math.max(0, effectivePop * 1.5 + 10 - attackingPop * attackRatio);
                    var taking = Math.min(f.pop * attackRatio, neededToTake);
                    if (taking > 0) {
                        var worth = Math.max(effectivePop, p.desirability * 5) + p.desirability * 5;
                        this.log('taking : ' + taking);
                        var importanceToAttacker = (taking / effectivePop * worth) / (10 + this.might[f.owner] / 3 );
                        var importanceToDefender = (taking / effectivePop * worth) / (50 + this.might[effectiveOwner] / 3);
                        var importance = (importanceToAttacker + importanceToDefender) * conquerFactor;
                        this.log('imp: ' + importance);
                        if (effectiveOwner == this.ownerId) {
                            this.enmity[f.owner] += importance;
                            this.enmity[f.owner] = Math.max(this.enmity[f.owner], importance * 6);
                        }
                        else if (effectiveOwner == this.topEnemy || effectiveOwner == this.hatedEnemy) {
                            this.enmity[f.owner] -= importance / 2;
                            this.enmity[effectiveOwner] -= importance / 10;
                        }
                        else {
                            this.enmity[f.owner] -= importance / 4;
                            this.enmity[effectiveOwner] -= importance / 6;
                        }
                    }
                }
            }

            //strat1
            this.doInfluenceStep = function (multiplier) {
                if (!multiplier)
                    multiplier = 50;
                var matrix;
                var p;
                var otherInfluence = 0;
                var spareInfluence = 0;
                var thisPlanetMultiplier;
                var i;
                var j;
                var idx;
                for (idx in planets) {
                    p = this.planetData[idx];
                    if (p.owner > 0) {
                        otherInfluence = 0;
                        matrix = distanceMatrix[idx];
                        //if (matrix.planetId != idx) alert('error ' + idx);
                        for (i in p.influence) {
                            if (i > 0 && i != p.owner)
                                otherInfluence += p.influence[i];
                        }
                        spareInfluence = p.influence[p.owner] - otherInfluence;
                        thisPlanetMultiplier = multiplier / distanceMatrixSumInverts[idx] / 100;
                        if (spareInfluence > 0) {
                            for (j in matrix) {
                                toPlanetData = this.planetData[matrix[j].planetId];

                                amt = spareInfluence * thisPlanetMultiplier / (matrix[j].dist + 40);
                                toPlanetData.influenceAddedThisStep[p.owner] += amt;
                                // NEUTRAL PLANES JUST GET 'EXTRA' INFLUENCE - NOT A FINITE QUANTITY
                                if (toPlanetData.owner > 0) {
                                    p.influenceAddedThisStep[p.owner] -= amt;
                                }
                            }
                        }

                    }
                }

                for (idx in planets) {
                    p = this.planetData[idx];
                    for (i in p.influenceAddedThisStep) {
                        p.influence[i] += p.influenceAddedThisStep[i];
                        p.influenceAddedThisStep[i] = 0;
                    }
                }


            }

            this.getTimeRange = function (dist, cooldown) {
                for (idx in this.timeRanges) {
                    if (dist / fleetspeed + cooldown < (this.timeRanges[idx] + 1)) {
                        return idx;
                    }
                }
                return 3;
            }

            this.calcFinalInfluenceByType = function () {
                this.threatInfluence = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                var idx;
                for (idx in this.enmity) {
                    this.enmity[idx] = this.enmity[idx] * .98 - .01;
                }
                this.enmity[0] = 1;
                var p;
                var i;
                var j;
                var dist;
                var dmd;
                //var senderOwner;
                for (idx in planets) {



                    p = this.planetData[idx];



                    p.aiInfluence = 0;
                    p.planetInfluence = 0;
                    p.otherInfluence = 0;
                    for (i in p.influence) {
                        if (i == p.owner) {
                            p.planetInfluence += p.influence[i];
                        }
                        else
                            p.otherInfluence += p.influence[i];
                        if (i == this.ownerId) {
                            p.aiInfluence += p.influence[i];
                        }

                    }
                    if (p.owner == this.ownerId) {
                        var otherInf = p.influence;
                        otherInf[this.ownerId] = -99;
                        var maxthreatI = getMaxIndex(otherInf);
                        this.threatInfluence[maxthreatI] += p.influence[maxthreatI] * (p.desirability + .5);
                    }
                    //if (p.planetInfluence == 0)
                    //    console.log('0 influence of owner??? ' + p.planetId);
                    p.safetyMargin = p.planet.pop * (p.planetInfluence - p.otherInfluence) / (p.planetInfluence + p.otherInfluence);
                    p.sendable = Math.max(0, p.safetyMargin);
                }

                for (idx = 1 ; idx <= numPlayers; idx++) {
                    if (idx != this.ownerId) {
                        var add = (this.threatInfluence[idx] / (this.might[idx] / 2 + this.might[this.ownerId] + 10)) * .01;

                        this.enmity[idx] += add;
                    }
                }
                var sizeRatio;
                for (idx in planets) {
                    p = this.planetData[idx];
                    for (j in distanceMatrix[p.planetId]) {
                        dmd = distanceMatrix[p.planetId][j];
                        if (this.planetData[dmd.planetId].owner == this.ownerId) {

                        }
                        else {

                        }

                        r = this.getTimeRange(dmd.dist, planets[dmd.planetId].cooldown);
                        var senderPlanet = this.planetData[dmd.planetId];

                        if (senderPlanet.owner > 0) {
                            //senderInfluence = senderPlanet.planetInfluence;
                            //sendMaxAmt = Math.min((senderPlanet.planetInfluence / (senderPlanet.planetInfluence + senderPlanet.otherInfluence) * p.planet.pop) / 2, senderPlanet.planet.pop);
                            sendMaxAmt = senderPlanet.sendable;
                            if (sendMaxAmt != 0 && !sendMaxAmt > 0) {
                                //console.log('sendmax ' + senderPlanet.planetId + ' NaN ' + senderPlanet.planetInfluence);
                            }
                            if (r < 2 && p.desirability > senderPlanet.desirability) {
                                sizeRatio = (p.desirability + 2) / (senderPlanet.desirability + 2) * .5;
                                sendMaxAmt += (senderPlanet.planet.pop - sendMaxAmt) * sizeRatio;
                            }

                            if (senderPlanet.owner == p.owner) {
                                p.planetMaxByTime[r] += sendMaxAmt;
                                //if (p.planetMaxByTime[r] != 0 && !p.planetMaxByTime[r] > 0) {
                                //console.log('ERROR ' + senderPlanet.planetInfluence);
                                //}
                            }
                            if (senderPlanet.owner == this.ownerId) {
                                p.aiMaxByTime[r] += sendMaxAmt;
                            }
                            else if (senderPlanet.owner != p.owner) {

                                p.otherMaxByTime[r] += sendMaxAmt * this.enmitySendRatio[i];

                                if (p.owner > 0 && this.enmity[senderPlanet.owner] * 2 + 1 < this.enmity[p.owner]) {
                                    p.planetMaxByTime[r] -= sendMaxAmt * .5;
                                }
                                //p.oppositionByTime[r] += sendMaxAmt * this.enmitySendRatio[i];
                            }

                        }
                    }

                }

            }

            this.log = function (msg, logLevel) {

                if (!logLevel)
                    logLevel = 1;
                if (this.logLevel >= logLevel) {
                    var temp = msg;
                    console.log(temp);

                }

            };

            this.checkAndSend = function (fromId, to, percent) {

                if (this.planetData[fromId].lastSent >= turnId - 4 || planets[fromId].cooldown)
                    return;
                tryCreateCommand(planets[fromId], planets[to], percent, this.ownerId);

                this.planetData[fromId].lastSent = turnId;
            };

            this.calcSendAmt = function (from, to, isRally) {
                var maxSendAmt = from.sendable - from.want / 2;
                var maxReceiveAmt = 0 - to.safetyMargin + to.want;
                if (isRally)
                    maxReceiveAmt = 0 - to.safetyMargin + to.want * 10;
                var amt = Math.min(maxSendAmt, maxSendAmt / 2 + maxReceiveAmt / 2);
                return amt;
            }

            this.checkAndSendAllExcess = function (from, to, isRally) {


                var percent = 100 * this.calcSendAmt(from, to, isRally) / from.planet.pop;
                this.checkAndSend(from.planetId, to.planetId, percent);
            }

            this.doTurn1 = function () {
                var idx;
                var i;
                this.doThisTurn = Math.random() * Math.random() * 100 > settings.lethargy
                && turnId % 2 == 0;




                // own planets:  other-influence(danger) vs  self-influence(safety)
                // other planets:  danger vs greed vs self-influence
                // send ships to:   short term other>self; long term self>=other

                this.might = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                this.numShips = Array.apply(null, Array(numPlayers + 1)).map(Number.prototype.valueOf, 0);
                var p;
                var totalMight = 0;
                var planetMight;
                for (idx in planets) {

                    p = this.planetData[idx];
                    p.setStartTurnVals();
                    //this.planetData.push(new PlanetData(p));

                    if (p.owner > 0) {
                        planetMight = p.planet.pop + (80) * p.growthPerTurn;
                        this.might[p.owner] += planetMight;
                        totalMight += planetMight;
                        this.numShips[p.owner] += p.planet.pop;
                    }


                    // TODO:
                    p.planetActualByTime[0] = p.planet.pop;
                    p.actualByOwner[p.owner] += p.planet.pop / attackRatio;
                    p.planetMaxByTime[0] = p.planet.pop;

                    if (p.owner > 0) {
                        p.planetActualByTime[0] += this.timeRanges[0] * p.growthPerTurn * .2;
                        p.planetActualByTime[1] = this.timeRanges[0] * p.growthPerTurn;
                        p.planetActualByTime[2] = this.timeRanges[1] * p.growthPerTurn;
                        p.planetActualByTime[3] = this.timeRanges[2] * p.growthPerTurn;

                        p.planetMaxByTime[0] += this.timeRanges[0] * p.growthPerTurn;
                        p.planetMaxByTime[1] = this.timeRanges[1] * p.growthPerTurn;
                        p.planetMaxByTime[2] = this.timeRanges[2] * p.growthPerTurn;
                        p.planetMaxByTime[3] = this.timeRanges[2] * p.growthPerTurn * 1.5;
                    }
                    if (p.owner == this.ownerId) {
                        for (r = 0; r <= 3; r++) {
                            p.aiMaxByTime[r] = p.planetMaxByTime[r];
                            p.aiActualByTime[r] = p.planetActualByTime[r];
                        }
                    }
                }
                var r;
                for (idx in fleets) {
                    f = fleets[idx];
                    p = this.planetData[f.destination.index];

                    mult = 400 / (Math.max(200, f.distToGo) + 200);
                    //if (f.owner == p.owner) {
                    //    p.actualDefence += f.pop * mult;
                    //}
                    //else {
                    //    mult = mult * .8;
                    //    p.actualAttack += f.pop * mult;
                    //}
                    p.influence[f.owner] += f.pop * mult;
                    this.might[f.owner] += f.pop;
                    totalMight += f.pop;
                    this.numShips[f.owner] += f.pop

                    r = this.getTimeRange(f.distToGo, 0);

                    if (f.owner == p.owner) {
                        p.planetActualByTime[r] += f.pop;
                        p.planetMaxByTime[r] += f.pop;
                    }
                    if (f.owner == this.ownerId) {
                        p.aiActualByTime[r] += f.pop;
                        p.aiMaxByTime[r] += f.pop;
                    }
                    else if (f.owner != p.owner) {
                        //p.planetActualByTime[r] -= f.pop;
                        //p.planetMaxByTime[r] -= f.pop;
                        p.otherActualByTime[r] += f.pop;
                        p.actualByOwner[f.owner] += f.pop;
                        p.otherMaxByTime[r] += f.pop;

                    }
                    else if (p.owner == this.ownerId) {
                        //p.aiActualByTime[r] -= f.pop;
                        //p.aiMaxByTime[r] -= f.pop;
                    }

                }
                for (idx in planets) {
                    p = this.planetData[idx];
                    p.effectiveOwner = getMaxIndex(p.actualByOwner);
                }
                this.topEnemy = -1;
                this.hatedEnemy = -1;
                var topEnemyMight = -1;
                var maxEnmity = -1;
                if (this.might[this.ownerId] == 0)
                    this.isDead = true;

                
                for (i in this.enmity) {
                    if (i > 0 && i != this.ownerId) {

                        if (this.enmity[i] > maxEnmity) {
                            this.hatedEnemy = i;
                            maxEnmity = this.enmity[i];
                        }
                    }
                }

                for (i in this.might) {
                    if (i > 0 && i != this.ownerId) {
                        this.attackPref[i] = Math.max(this.enmity[i], 0);
                        this.enmitySendRatio[i] = Math.min(.8, Math.max(this.enmity[i], .3));
                        if (this.might[i] > topEnemyMight) {
                            this.topEnemy = i;
                            topEnemyMight = this.might[i];
                        }
                    }
                }
                if (this.topEnemy > 0) {
                    var imbalance = Math.min(10, topEnemyMight / (totalMight - topEnemyMight + 1));

                    this.enmity[this.topEnemy] = Math.max(this.enmity[this.topEnemy], 1 + imbalance);

                    this.mapWideDanger = 0;
                    if (this.numShips[this.topEnemy] > this.numShips[this.ownerId]) {
                        this.mapWideDanger = Math.sqrt(this.numShips[this.topEnemy] - this.numShips[this.ownerId]);
                    }
                    if (this.mapWideDanger < 0)
                        this.mapWideDanger = 0;
                    this.attackPref[this.topEnemy] = Math.max(0, this.attackPref[this.topEnemy]) * (1 + imbalance / 2) + imbalance / 2;
                }

                if (this.announceHateThreshhold > 1) { this.announceHateThreshhold *= .998; }
                if (this.announceLikeThreshhold < 0) { this.announceLikeThreshhold *= .9995; }
                if (!this.isDead) {
                    if (this.loversPlayer > 0) {
                        this.enmity[this.loversPlayer] = -10;
                        this.attackPref[this.loversPlayer] = -10;
                    }
                    for (i in this.attackPref) {
                        if (i > 0 && i != this.ownerId) {
                            var msg = '';
                            if (this.enmity[i] > 1 && this.enmity[i] > this.announceHateThreshhold) {
                                this.announceHateThreshhold = this.announceHateThreshhold * 2 + 1;
                                
                                if (this.might[this.ownerId] * 2 < this.might[i])
                                    msg = getHelpMsg(this.enmity[i]);
                                else if (this.topEnemy == i && this.might[this.ownerId] < this.might[i])
                                    msg = 'Everyone attack {0}!';
                                else
                                    msg = getThreatMsg(this.enmity[i]);
                            }

                            if (this.enmity[i] < this.announceLikeThreshhold)
                            {
                                this.announceLikeThreshhold = this.announceLikeThreshhold * 1.5 - 1;
                                msg = getLikeMsg(this.enmity[i]);
                            }
                            if (msg > '')
                            {
                                var sendMsg = msg;
                                var thisAi = this;
                                var toAi = i;
                                setTimeout(function () {
                                    sendFormattedChat(thisAi.ownerId, toAi, sendMsg );
                                }, 100);
                                break;
                            }
                        }
                    }
                }
                if (this.doThisTurn) {
                    this.doInfluenceStep(40);

                }
            };

            this.doTurn2 = function () {
                if (this.doThisTurn) {
                    this.doInfluenceStep(60);
                }
            };

            this.doTurn3 = function () {
                if (this.doThisTurn) {
                    this.doInfluenceStep(70);
                }
            };

            this.doTurn4 = function () {
                if (this.doThisTurn) {
                    this.calcFinalInfluenceByType();

                }
            }

            this.doTurnFinal = function () {
                if (this.doThisTurn) {

                    var idx;
                    var p;
                    var r;
                    this.myPlanets = [];
                    var willLose, attRatio;

                    for (idx in this.planetData) {
                        p = this.planetData[idx];
                        p.danger = [0, 0, 0, 0];
                        p.inDanger = false;
                        // fix actuals
                        for (r = 0; r < 3; r++) {
                            p.aiActualByTime[r + 1] += p.aiActualByTime[r];
                            p.otherActualByTime[r + 1] += p.otherActualByTime[r];
                            p.planetActualByTime[r + 1] += p.planetActualByTime[r];
                            p.aiMaxByTime[r + 1] += p.aiMaxByTime[r];
                            p.otherMaxByTime[r + 1] += p.otherMaxByTime[r];

                            p.planetMaxByTime[r + 1] += p.planetMaxByTime[r];
                        }
                        for (r = 0; r <= 3; r++) {
                            p.planetMaxByTime[r] = Math.max(p.planetMaxByTime[r], 0);
                        }
                        if (p.owner != this.ownerId) {
                            for (r = 0; r <= 3; r++) {
                                p.oppositionByTime[r] = p.otherMaxByTime[r] + p.planetMaxByTime[r];
                            }
                        }
                        willLose = false;
                        attRatio = attackRatio;


                        if (p.owner == this.ownerId) {


                            for (r = 0; r <= 3; r++) {

                                if (p.otherActualByTime[r] * attRatio > p.planetActualByTime[r]) {

                                    p.danger[r] = p.otherActualByTime[r] * attRatio - p.planetActualByTime[r];
                                    p.inDanger = true;

                                }
                                if (p.otherActualByTime[r] * attRatio > p.planet.pop) {
                                    p.dependsonReinforcements = true;
                                }

                                if (p.otherActualByTime[r] * attRatio > p.planetMaxByTime[r]) {
                                    if (r == 0) {
                                        attRatio = 1 / attackRatio;
                                    }
                                    else if (r < 3) {
                                        attRatio = Math.max(attRatio, 1);
                                    }
                                    else if (r == 3) {
                                        this.log('will lose planet');
                                        this.log(p.planetMaxByTime);
                                        this.log(p.otherActualByTime);
                                        willLose = true;
                                    }
                                }

                            }





                            // excess/need/canhold
                            this.myPlanets.push(p);

                            var stubborn = this.stubbornChance + Math.random() * Math.random() > 1;
                            if (!willLose || stubborn) {

                                //p.safetyMargin = Math.min(p.safetyMargin, p.planetMaxByTime[1] - p.otherMaxByTime[1]/2);
                                if (p.safetyMargin < 0) {
                                    p.safetyMargin = p.safetyMargin * (.4 + p.desirability * .15);
                                }

                                p.urgency = 0 - p.safetyMargin / 1000;
                                //this.log('excess calc ' + p.safetyMargin);
                                if (p.inDanger) {
                                    for (r in p.danger) {
                                        p.safetyMargin = Math.min(p.safetyMargin, 0 - p.danger[r]);
                                    }
                                    p.urgency = 50 / (0 - p.safetyMargin + 5);
                                }

                            }
                            else if (willLose) {

                                console.log('estimate cant defend');
                                p.want = p.safetyMargin = p.planet.pop;
                            }
                            if (p.safetyMargin < 0) {
                                p.urgency += (p.desirability - .5) * p.desirability;
                            }


                        }
                        else {
                            // NOT OWN PLANET
                            // TODO: store influence by r, or maxbytime by owner
                            //for (r = 0; r <= 3; r++) {
                            //    p.oppositionByTime[r] = p.planetMaxByTime[r];
                            //    for (i in this.enmity) {
                            //        if (i > 0 && i != this.ownerId && i != p.owner && this.enmity[i] > 0) {
                            //            p.oppositionByTime[r] += p.influence[i] * Math.min(1, Math.max(.5, this.enmity[i]) ) ;
                            //        }
                            //    }
                            //}

                            // target? -> rally points
                            // thumbsuck just to see if target worth investigating
                            var numplanets = this.myPlanets.length;
                            var likelymight = this.might[this.ownerId] / (numplanets + 4);
                            var likelydefmight = (this.might[p.owner] + this.might[p.effectiveOwner]) / 20;
                            goodTarget1 = (p.aiInfluence + likelymight / 5) / (p.planetInfluence + p.otherInfluence - p.aiInfluence + 5 / p.desirability + likelydefmight / 5);
                            goodTarget2 = (Math.max(likelymight / 2 + p.aiMaxByTime[3] / 2, p.aiMaxByTime[3])) / (p.oppositionByTime[3] + 5 / p.desirability + likelydefmight / 5);
                            goodTarget3 = (p.aiMaxByTime[1]) / (p.oppositionByTime[1] + .0001);
                            p.goodTarget = (goodTarget1 + goodTarget2 + goodTarget3) / 3
                            //+ Math.max(goodTarget1, goodTarget2, goodTarget3) / 2;
                            if (p.goodTarget > 0) {
                                p.goodTarget *= Math.min(2, (-.5 + this.attackPref[p.effectiveOwner] * 1.5));
                                p.goodTarget *= p.goodTarget;
                                //this.log(p.goodTarget);
                            }
                            else if (p.goodTarget != 0) {
                                console.log('ERROR target calc planet ' + p.planetId + ': t1 ' + goodTarget1 + ' t2 ' + goodTarget2 + ' t3 ' + goodTarget3);
                            }
                            var willWin = false;
                            var alreadyWon = false;
                            if (p.desirability == 4)
                                p.goodTarget *= 3;
                            if (p.goodTarget > .1) {
                                p.goodTarget *= (.8 + p.desirability / 3);

                                var riskPercent;
                                attRatio = attackRatio;
                                for (r = 0; r <= 3; r++) {

                                    if (p.aiActualByTime[r] * attackRatio > p.planetMaxByTime[r]) {
                                        alreadyWon = true;
                                    }
                                    else {
                                        if (alreadyWon)
                                            alreadyWon = false; // got it but lost it again
                                    }
                                    if (p.aiMaxByTime[r] * attRatio > p.planetMaxByTime[r]) {
                                        if (r == 0) {
                                            attRatio = 1 / attRatio;

                                            this.log('won first phase: ' + attRatio, 2);

                                        }
                                        else if (r == 1) {
                                            attRatio = Math.max(attRatio, 1);
                                            this.log('won 2nd phase: ' + attRatio, 2);
                                        }
                                        else {

                                            this.log('won', 2);

                                            willWin = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (alreadyWon) {
                                this.log('already won', 2);
                                p.goodTarget = 0;
                            }
                            else {
                                //base this on potential, ignoring willWin
                                matrix = distanceMatrix[p.planetId];
                                //if (matrix.planetId != idx) alert('error ' + idx);
                                for (j in matrix) {
                                    toPlanetData = this.planetData[matrix[j].planetId];
                                    if (toPlanetData.owner == this.ownerId) {
                                        amt = p.goodTarget / (matrix[j].dist + 40);
                                        //this.log('rally adding ' + amt);
                                        toPlanetData.goodRallyPoint += amt;
                                    }
                                }
                            }


                            if (p.lastDidntAttack > turnId - 20) {
                                p.goodTarget = 0;
                            }
                            else if (willWin)
                                p.goodTarget += .25;

                        }
                        // no need to fix dangers cos already based on fixed byTime's
                    }
                    var i;
                    for (idx in this.myPlanets) {
                        p = this.planetData[idx];
                        if (p.otherInfluence > 0) {
                            // don't threaten friends, but do protect against everyone:
                            for (i in p.influence) {
                                if (i != p.effectiveOwner && this.enmity[i] < 1) {
                                    p.want -= p.influence[i] * (1 - Math.max(0, this.enmity[i]));
                                }
                            }
                            // ask for help from nearby planets
                            matrix = distanceMatrix[p.planetId];
                            //if (matrix.planetId != idx) alert('error ' + idx);
                            for (j in matrix) {
                                sp = this.planetData[matrix[j].planetId];
                                sp.want += p.otherInfluence / (Math.max(matrix[j].dist, 100) / 100)
                            }
                        }
                    }
                    if (this.myPlanets.length) {

                        var mostNeed = this.myPlanets.concat().sort(function (a, b) { return a.urgency + a.goodTarget > b.urgency + b.goodTarget ? -1 : 1 });

                        var r;
                        var sendAmt;
                        var sentEnough;
                        var sentAnything;
                        var need = mostNeed[0];
                        if (need.urgency > 0 && need.inDanger) {
                            var supplyByTime = [0, 0, 0, 0];
                            //var suppliers = [[], [], [], []];
                            var rangeStillInDanger = 0;
                            var sizeRatio;
                            for (var idx in distanceMatrix[need.planetId]) {
                                sendAmt = 0;
                                var dp = distanceMatrix[need.planetId][idx].planetId;
                                if (planets[dp].owner == this.ownerId) {
                                    if (this.planetData[dp].lastSent <= turnId - 5) {

                                        // if (this.planetData[dp].planet.pop + this.planetData[dp].safetyMargin > (0 - need.safetyMargin)) {
                                        if (1 == 1) {
                                            var stillNeedAmt = need.danger[rangeStillInDanger] - supplyByTime[rangeStillInDanger];
                                            this.log('still need to defend: ' + stillNeedAmt);
                                            while (stillNeedAmt <= 0) {
                                                // have we sent too much?
                                                rangeStillInDanger++;
                                                stillNeedAmt = need.danger[rangeStillInDanger] - supplyByTime[rangeStillInDanger];

                                                if (rangeStillInDanger == 3) {
                                                    sentEnough = true;
                                                    break;
                                                }
                                            }

                                            r = this.getTimeRange(distanceMatrix[need.planetId][idx].dist, planets[dp].cooldown);
                                            if (r > rangeStillInDanger) {
                                                this.log('thought could defend, but too far away');
                                                // should hardly ever happen, cos of WillLose
                                                //console.log('unable to defend planet - aborting rescue: ');
                                                //console.log(need.planet);
                                                break;
                                            }
                                            // we're going to send support if possible.
                                            //sendAmt = this.planetData[dp].safetyMargin;
                                            sendAmt = this.planetData[dp].sendable;

                                            if (r < 2) {
                                                sizeRatio = (need.desirability + 2) / (this.planetData[dp].desirability + 2) * .5;
                                                sendAmt += (this.planetData[dp].planet.pop - sendAmt) * sizeRatio;
                                            }



                                            sendAmt = Math.min(sendAmt, stillNeedAmt);
                                            percent = 100 * sendAmt / this.planetData[dp].planet.pop + 2;
                                            if (this.planetData[dp].owner != this.ownerId)
                                                console.log('error in defend');
                                            this.checkAndSend(dp, need.planetId, percent);
                                            sentAnything = true;
                                            supplyByTime[r] += sendAmt;
                                            if (r < 3) {
                                                for (rr = r; rr < 3; rr++) {
                                                    supplyByTime[rr + 1] += sendAmt;
                                                }
                                            }
                                            //suppliers[r].push(this.planetData[dp]);
                                        }
                                    }
                                }
                                if (sentEnough)
                                    break;
                            }


                        }


                        if (!sentAnything) {

                            var bestTargets = this.planetData.concat().sort(function (a, b) { return a.goodTarget > b.goodTarget ? -1 : 1 });
                            var target = bestTargets[0];
                            this.log('best target owner: ' + target.owner, 2);
                            this.log(target, 2);
                            if (target.owner != this.ownerId && target.goodTarget > .5 - Math.random() * Math.random()) {
                                var attackByTime = [0, 0, 0, 0];
                                //var suppliers = [[], [], [], []];
                                var rangeStillDefensible = 0;
                                // TODO: don't over-send - store amt to send?
                                var attackers = [];
                                var maxAnySendAmt = 0;
                                var attRatio = attackRatio;
                                var hasTakenAtLeastOnce = false;

                                var costToTake = 0;
                                var sendEffect;
                                var newAttackRatio;
                                var sizeRatio;
                                var takeAnyway = false;

                                //var recklessExtra = target.pop;
                                for (var idx in distanceMatrix[target.planetId]) {
                                    sendAmt = 0;
                                    var dp = distanceMatrix[target.planetId][idx].planetId;
                                    if (planets[dp].owner == this.ownerId) {
                                        if (this.planetData[dp].lastSent <= turnId - 5 && ! planets[dp].cooldown) {
                                            if (this.planetData[dp].planet.pop + this.planetData[dp].safetyMargin > target.planetInfluence) {
                                                newAttackRatio = attRatio;
                                                r = this.getTimeRange(distanceMatrix[target.planetId][idx].dist, planets[dp].cooldown);

                                                while (r > rangeStillDefensible) {
                                                    rangeStillDefensible++;
                                                    attackByTime[rangeStillDefensible] = attackByTime[rangeStillDefensible - 1];

                                                }



                                                sendAmt = this.planetData[dp].sendable;



                                                if (r < 2) {
                                                    sizeRatio = (target.desirability) / (this.planetData[dp].desirability);
                                                    sendPercentOfRemainder = Math.min(1, (.7 - r * .2) * sizeRatio);
                                                    this.log('sending proportion after safety margin: ' + sendPercentOfRemainder, 2);
                                                    sendAmt += (this.planetData[dp].planet.pop - sendAmt) * sendPercentOfRemainder;
                                                }
                                                sendEffect = sendAmt * attRatio;

                                                while (attackByTime[rangeStillDefensible] + sendEffect > target.planetMaxByTime[rangeStillDefensible] * 1.05) {
                                                    // have we sent too much?
                                                    if (attackByTime[rangeStillDefensible] + sendEffect > target.planetMaxByTime[rangeStillDefensible] * 1.1)
                                                        newAttackRatio = 1 / attackRatio;
                                                    else if (attackByTime[rangeStillDefensible] + sendEffect > target.planetMaxByTime[rangeStillDefensible] * 1.05)
                                                        newAttackRatio = 1;

                                                    if (!hasTakenAtLeastOnce) {
                                                        this.log('predict taking at least once', 2);
                                                        hasTakenAtLeastOnce = true;
                                                    }
                                                    this.log('safety send amt:' + sendAmt, 2);
                                                    sendAmt = Math.min(sendAmt, ((target.planetMaxByTime[3] + target.oppositionByTime[3]) * .55 - attackByTime[rangeStillDefensible]) / attRatio);
                                                    sendEffect = sendAmt * attRatio;
                                                    //this.log('actual send amt:' + sendAmt + ' | );
                                                    if (rangeStillDefensible < 3) {
                                                        rangeStillDefensible++;
                                                        attackByTime[rangeStillDefensible] = attackByTime[rangeStillDefensible - 1];
                                                    }
                                                    else {
                                                        if (attackByTime[3] + sendEffect > (target.planetMaxByTime[rangeStillDefensible] + target.oppositionByTime[rangeStillDefensible]) * .5) {
                                                            sentEnough = true;
                                                        }
                                                        else {
                                                            this.log('havent sent enought to secure? ' + (attackByTime[3] + sendEffect) + ' vs ' + ((target.planetMaxByTime[rangeStillDefensible] + target.oppositionByTime[rangeStillDefensible]) * .5));
                                                        }
                                                        break;
                                                    }
                                                }


                                                attRatio = newAttackRatio;


                                                attackByTime[rangeStillDefensible] += sendEffect;
                                                if (sendAmt > maxAnySendAmt)
                                                    maxAnySendAmt = sendAmt;
                                                attackers.push({ planet: this.planetData[dp], amt: sendAmt });
                                                //this.log('adding attacker, sending: ' + sendAmt);
                                                //this.log(attackByTime);
                                                if (sentEnough) {
                                                    break;
                                                }
                                                if (hasTakenAtLeastOnce && rangeStillDefensible > 0) {
                                                    var neededRatio = 1 + rangeStillDefensible * .2;

                                                    neededRatio += 1 / (1 + this.attackPref[target.effectiveOwner]);

                                                    costToTake = target.planetMaxByTime[rangeStillDefensible - 1];
                                                    this.log('costToTake ' + costToTake + '   sending: ' + attackByTime[rangeStillDefensible], 2);
                                                    if (attackByTime[rangeStillDefensible] > costToTake * neededRatio) {
                                                        this.log('might lose, but taking anyway!');
                                                        takeAnyway = true;
                                                    }

                                                }
                                                if (rangeStillDefensible == 3) {


                                                    if (!takeAnyway) {
                                                        this.log('unable to be sure of taking planet at r: ' + r, 2);
                                                        this.log(attRatio, 2);
                                                        this.log(attackByTime, 2);
                                                        this.log(target, 2);

                                                        target.lastDidntAttack = turnId;
                                                        attackers = [];
                                                        break;
                                                    }
                                                }
                                                //suppliers[r].push(this.planetData[dp]);
                                            }
                                        }
                                    }
                                    if (sentEnough) {
                                        break;
                                    }
                                }
                                if (sentEnough || takeAnyway) {
                                    sentAnything = true;
                                    var ap;
                                    for (var idx in attackers) {
                                        ap = attackers[idx].planet;
                                        percent = 100 * attackers[idx].amt / ap.planet.pop + 1;
                                        if (ap.owner != this.ownerId)
                                            console.log('error in attack');
                                        this.checkAndSend(ap.planetId, target.planetId, percent);
                                    }
                                }



                            }


                        }

                        if (!sentAnything && this.myPlanets.length > 2) {
                            if (Math.random() < .3) {
                                // ------------------ RALLY POINTS ---------------------------
                                this.log('------------ SEND TO RALLY POINTS', 2);
                                var bestRallies = this.myPlanets.concat().sort(function (a, b) { return a.goodRallyPoint > b.goodRallyPoint ? -1 : 1 });
                                if (!this.rallyPoints[0]
                                    || bestRallies[0].goodRallyPoint > this.rallyPoints[0].goodRallyPoint * 1.2
                                    // || bestRallies[1].goodRallyPoint > this.rallyPoints[1].goodRallyPoint * 1.5
                                    ) {
                                    this.rallyPoints[0] = bestRallies[0];



                                    if (1 == 2) {
                                        // if multiple rally points:
                                        var matrix = distanceMatrix[this.rallyPoints[0].planetId]
                                        var nonr;
                                        var dm;
                                        for (idx in matrix) {
                                            nonr = this.planetData[idx];
                                            dm = matrix[idx];
                                            nonr.goodRallyPoint = nonr.goodRallyPoint / (1 + 50 / dm.dist);
                                        }

                                        bestRallies = this.myPlanets.concat().sort(function (a, b) { return a.goodRallyPoint > b.goodRallyPoint ? -1 : 1 });
                                        this.rallyPoints[1] = bestRallies[1];
                                    }
                                }
                                //this.rallyPoints[0].want += 100;
                                //this.rallyPoints[1].want += 100;
                                var dist;
                                var donor;
                                //var score;
                                for (var r in [0]) {
                                    var rally = this.rallyPoints[r];
                                    var matrix = distanceMatrix[rally.planetId];
                                    //var willingDistance = 100 + Math.random() * Math.random() * Math.random() * 400;
                                    var bestScore = 0;
                                    var bestScorer;
                                    for (j in matrix) {
                                        donor = this.planetData[matrix[j].planetId];

                                        if (donor.owner != this.ownerId || donor == this.rallyPoints[0] || donor.dependsonReinforcements) {
                                            continue;
                                        }

                                        //dist = Math.sqrt(Math.pow(rally.planet.shape.x - donor.planet.shape.x, 2) + Math.pow(rally.planet.shape.y - donor.planet.shape.y, 2));
                                        if (donor.lastSent <= turnId - 10 && donor.safetyMargin > bestScore) {
                                            //this.log(donor,2);
                                            bestScore = Math.min(donor.safetyMargin, donor.planet.pop) - donor.planet.cooldown*3;
                                            bestScorer = donor;
                                        }

                                    }
                                    //console.log(bestScore)
                                    if (bestScorer && bestScore > 10) {
                                        this.log('RALLY best scorer ' + bestScore, 2);
                                        donor = bestScorer;
                                        //console.log('sending to rally');
                                        if (donor.owner != this.ownerId)
                                            console.log('error in rally');
                                        this.checkAndSendAllExcess(donor, rally, true);
                                        sentAnything = true;
                                        break;
                                    }
                                }
                            }
                            if (!sentAnything) {
                                // ------------------ GENERAL MIGRATION ---------------------------
                                this.log('------------ OVERPOPS', 2);
                                var overpops = this.myPlanets.concat().sort(function (a, b) { return (a.safetyMargin - a.want > b.safetyMargin - b.want) ? -1 : 1 });
                                this.log(overpops, 2);
                                var donorid = 0;
                                if (this.rallyPoints[0]) {
                                    while (overpops[donorid] == this.rallyPoints[0]) {
                                        donorid++;
                                        if (donorid >= overpops.length - 1)
                                            break;
                                    }
                                }

                                while (overpops[donorid].dependsonReinforcements || overpops[donorid].planet.cooldown) {

                                    donorid++;
                                    if (donorid >= overpops.length - 1)
                                        break;
                                }

                                if (donorid < overpops.length - 1) {
                                    var sendAmt;
                                    var donor = overpops[donorid];
                                    if (donor.safetyMargin > 10 && donor.lastSent <= turnId - 10) {

                                        var willingDistance = 200 + Math.random() * Math.random() * Math.random() * 500;
                                        for (idx = 0; idx < overpops.length / 2; idx++) {
                                            recipient = overpops[overpops.length - idx - 1];
                                            dist = Math.sqrt(Math.pow(recipient.planet.shape.x - donor.planet.shape.x, 2) + Math.pow(recipient.planet.shape.y - donor.planet.shape.y, 2));
                                            this.log('willing dist: ' + willingDistance + ' . safetaymargin: ' + donor.safetyMargin, 2);
                                            sendAmt = this.calcSendAmt(donor, recipient);
                                            if (dist < willingDistance + sendAmt * 3) {

                                                if (donor.owner != this.ownerId)
                                                    console.log('error in overpops');
                                                this.checkAndSendAllExcess(donor, recipient);
                                                sentAnything = true;

                                                break;
                                            }
                                            //willingDistance *= 1.1;
                                        }
                                    }
                                }
                            }
                        }



                        this.log('----danger--', 2);
                        //this.log(this.planetData);
                        this.log(mostNeed, 2);
                        //this.log('----rallypoints--');
                        //this.log(bestRallies);
                        this.log('----targets--', 2);
                        this.log(bestTargets, 2);
                        this.log(this, 2);
                        if (!this.logContinuous) {
                            this.logLevel = 0;
                        }


                    } // end - if has any planets
                }
            };

        }


    </script>

</head>
<body onload="" style="margin:0; background-color:#224422">
    <canvas id="PalCanvas" width="1" height="1" style="float:left;"></canvas>
    <div id="pregame" class="clearfix" style="color:white; padding:10px">
        <h2>PalConq</h2>
        <div class="chrome_warning">
            You are not using a browser that's not Chrome.<br />For best results, please run Chrome and come back.
        </div>


        Waiting for players. Joined: <span id="playersLabel"></span>
        <br /><br />
        Suggestion: Before starting, hit <b>F11</b> to go fullscreen</span>
        <br /><br />
        <button id="btnStart" style="visibility:hidden" onclick="startGame();">START GAME</button>
        <hr />
        <div class="clearfix">
            <div class="rows">
                <h3>Change game settings</h3>
                <div>
                    <label>AI Lethargy (%): </label>
                    <input type="text" id="lethargy" />
                </div>

                <div>
                    <label>Neutral Planet Cost:</label>
                    <input type="text" id="costs" />
                </div>

                <div>
                    <label>Add AI Players up to:</label>
                    <select id="minplayers">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                </div>
                <div class="more_container">
                    <a href="#" class="more_button">show experimental settings...</a>
                    <div class="more">
                        <div>
                            <label>Fleet Speed: </label>
                            <input type="text" id="fleetspeed" />
                        </div>
                        <div>
                            <label>Growth Rate:</label>
                            <input type="text" id="growthrate" />
                        </div>
                        <div>
                            <label># Planets (3 player):</label>
                            <input type="text" id="ppp" />
                        </div>
                        <div>
                            <label>Attack ratio:</label>
                            <input type="text" id="attack" />
                        </div>
                    </div>
                </div>
                <div>
                    <button id="btnSettings" onclick="sendSettings();">UPDATE SETTINGS</button>
                </div>

            </div>
            <div class="colours">
                <h3>Choose your preferred colour</h3>
                <div>
                    @for (var c = 1; c < Model.Count(); c++)
                    {
                        <div style="border-color:@(Model[c])">
                            <input value="@(c)" type="radio" name="colour" />
                        </div>
                    }
                </div>
            </div>
        </div>
        <hr />
        <div>
            <h3>First Time?</h3>
            <b>Objective:</b> Capture all the large planets <small>(each player's home planet, plus the big neutral planet)</small>
            <br /><br />
            Planets are neutral (grey) or owned by a player.  A number on the planet shows the population, which can be sent off in ships or left on the planet to defend against attacking ships.
            <br /><br />
            Defending is slightly more efficient than attacking: To capture a neutral planet of '80', you need to attack with ships totalling 100 population.
            <br /><br />
            Small, medium, and large planets grow new population at a rate of 1, 2 or 4.
            <br /><br />
            You start with one large planet (as the game starts, a flash of colour and a circle centering on your planet show you who are)
            <br /><br />
            Start expaneding as fast as possible: find nearby neutral planets with few defenders (remembering that a medium planet is worth two small planets) and send ships big enough to take them.
            Avoid taking planets right next to strong enemy planets, because you might end up softening up the planet for the enemy.
            <br /><br />
            <b>How to win:</b> Expand fast where no enemies are near.  When neighbours expand close to you, keep some well defended planets near your 'border' as a deterrent.  Keep an eye out for an over-extended neighbour: attack them before their new planets generate too many defenders.
            <br /><br />
            Most importantly, use positioning to encourage your enemies to fight each other.  If caught between them, it may be worth evacuating a few planets and letting the enemies fight it out.
        </div>
    </div>
    <div id="rightcontainer">
        <h3 class="top0">Instructions</h3>
        <div id="instructions">

            <div>
                <label>Select planets:</label><span>click / ctrl-click</span>
                <br />
                <label>Send fleet:</label><span>hold right-click</span>
            </div>
            <div>
                <label>Send repeat-order:</label><span>hold <b>Z</b> + right-click</span>
                <br />
                <label>Cancel repeat-orders:</label><span>select planet(s), then <b>X</b></span>

            </div>


        </div>
        <br />
        <div id="controls" class="clearfix">
            <button id="newgame" onclick="newGame()">Restart</button>
            <button id="surrender" onclick="sendSurrender()">Surrender</button>
            <button id="surrender" onclick="togglePause()" style="display:none">Pause</button>
        </div>
        <br />
        <div id="chat_scroller" style="height:50vh">
            <div style="height:99%"></div>
        </div>
        <br />
        <input type="text" id="chat_input" placeholder="CHAT...." />
        <br />
        <div id="fullscreen_msg">
            Press F11 for fullscreen!
        </div>

    </div>
    <div class="waitforsignalr">
        <div>
            Setting up communication with server.
            <br />
            Should only take 1 second....
        </div>
    </div>
</body>
</html>



<!--function init() {
  var stage = new createjs.Stage("demoCanvas");
  var circle = new createjs.Shape();
  circle.graphics.beginFill("Crimson").drawCircle(0, 0, 50);
  circle.x = 100;
  circle.y = 100;
  stage.addChild(circle);
  createjs.Tween.get(circle, {loop: true})
    .to({x: 400}, 1000, createjs.Ease.getPowInOut(4))
    .to({alpha: 0, y: 75}, 500, createjs.Ease.getPowInOut(2))
    .to({alpha: 0, y: 125}, 100)
    .to({alpha: 1, y: 100}, 500, createjs.Ease.getPowInOut(2))
    .to({x: 100}, 800, createjs.Ease.getPowInOut(2));
  createjs.Ticker.setFPS(60);
  createjs.Ticker.addEventListener("tick", stage);
}-->
